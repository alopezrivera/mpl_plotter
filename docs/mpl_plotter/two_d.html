<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>mpl_plotter.two_d API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mpl_plotter.two_d</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys
import inspect
import numpy as np
import pandas as pd
import datetime as dt
import matplotlib as mpl

from importlib import import_module

from matplotlib import cm
from matplotlib import font_manager as font_manager
from matplotlib.ticker import FormatStrFormatter

from mpl_plotter.methods.mock_data import MockData
from alexandria.shell import print_color
from alexandria.data_structs.array import span, ensure_ndarray


class canvas:

    def method_backend(self):
        if not isinstance(self.backend, type(None)):
            try:
                mpl.use(self.backend)
            except AttributeError:
                raise AttributeError(&#39;{} backend not supported with current Python configuration&#39;.format(self.backend))

        # matplotlib.use() must be called *before* pylab, matplotlib.pyplot,
        # or matplotlib.backends is imported for the first time.

    def method_fonts(self):
        &#34;&#34;&#34;
        Fonts
        Reference:
            - https://matplotlib.org/2.0.2/users/customizing.html
        Pyplot method:
            plt.rcParams[&#39;&lt;category&gt;.&lt;item&gt;&#39;] = &lt;&gt;
        &#34;&#34;&#34;
        mpl.rc(&#39;font&#39;, family=self.font)
        mpl.rc(&#39;font&#39;, serif=&#34;DejaVu Serif&#34; if self.font == &#34;serif&#34; else self.font)
        self.plt.rcParams[&#39;font.sans-serif&#39;] = &#34;DejaVu Serif&#34; if self.font == &#34;serif&#34; else self.font
        mpl.rc(&#39;font&#39;, cursive=&#34;Apple Chancery&#34; if self.font == &#34;serif&#34; else self.font)
        mpl.rc(&#39;font&#39;, fantasy=&#34;Chicago&#34; if self.font == &#34;serif&#34; else self.font)
        mpl.rc(&#39;font&#39;, monospace=&#34;Bitstream Vera Sans Mono&#34; if self.font == &#34;serif&#34; else self.font)

        mpl.rc(&#39;mathtext&#39;, fontset=self.math_font)
        mpl.rc(&#39;text&#39;, color=self.font_color)

    def method_setup(self):
        if isinstance(self.fig, type(None)):
            if not self.plt.get_fignums():
                self.method_figure()
            else:
                self.fig = self.plt.gcf()
                self.ax = self.plt.gca()

        if isinstance(self.ax, type(None)):
            self.ax = self.fig.add_subplot(self.shape_and_position, adjustable=&#39;box&#39;)

    def method_figure(self):
        if not isinstance(self.style, type(None)):
            self.plt.style.use(self.style)
        self.fig = self.plt.figure(figsize=self.figsize)

    def method_grid(self):
        if self.grid:
            self.ax.grid(linestyle=self.grid_lines, color=self.grid_color)


class attributes:

    def method_background_color(self):
        self.fig.patch.set_facecolor(self.background_color_figure)
        self.ax.set_facecolor(self.background_color_plot)
        self.ax.patch.set_alpha(self.background_alpha)

    def method_workspace_style(self):
        if self.light:
            self.workspace_color = &#39;black&#39; if isinstance(self.workspace_color, type(None)) else self.workspace_color
            self.workspace_color2 = (193/256, 193/256, 193/256) if isinstance(self.workspace_color2, type(
                None)) else self.workspace_color2
            self.style = &#39;classic&#39;
        elif self.dark:
            self.workspace_color = &#39;white&#39; if isinstance(self.workspace_color, type(None)) else self.workspace_color
            self.workspace_color2 = (89/256, 89/256, 89/256) if isinstance(self.workspace_color2,
                                                                                 type(
                                                                                     None)) else self.workspace_color2
            self.style = &#39;dark_background&#39;
        else:
            self.workspace_color = &#39;black&#39; if isinstance(self.workspace_color, type(None)) else self.workspace_color
            self.workspace_color2 = (193/256, 193/256, 193/256) if isinstance(self.workspace_color2, type(
                None)) else self.workspace_color2

    def method_cb(self):
        if self.color_bar is True:
            if isinstance(self.norm, type(None)):
                return print_color(&#34;No norm selected for colorbar. Set norm=&lt;parameter of choice&gt;&#34;, &#34;grey&#34;)

            # Obtain and apply limits
            if isinstance(self.cb_vmin, type(None)):
                self.cb_vmin = self.norm.min()
            if isinstance(self.cb_vmax, type(None)):
                self.cb_vmax = self.norm.max()
            self.graph.set_clim([self.cb_vmin, self.cb_vmax])

            # Normalization
            locator = np.linspace(self.cb_vmin, self.cb_vmax, self.cb_tick_number)

            # Colorbar
            cb_decimals = self.tick_ndecimals if isinstance(self.cb_tick_ndecimals, type(None)) \
                else self.cb_tick_ndecimals
            cbar = self.fig.colorbar(self.graph,
                                     ax=self.ax,
                                     # Add option to have different colormap and colorbar ranges
                                     norm=mpl.colors.Normalize(vmin=self.cb_vmin, vmax=self.cb_vmax),
                                     # Add option to have different colormap and colorbar ranges
                                     orientation=self.cb_orientation, shrink=self.shrink,
                                     ticks=locator,
                                     boundaries=locator if self.cb_hard_bounds is True else None,
                                     spacing=&#39;proportional&#39;,
                                     extend=self.extend,
                                     format=&#39;%.&#39; + str(cb_decimals) + &#39;f&#39;,
                                     pad=self.cb_pad,
                                     )

            # Ticks
            #   Locator
            cbar.locator = locator
            #   Direction
            cbar.ax.tick_params(axis=&#39;y&#39;, direction=&#39;out&#39;)
            #   Tick label pad and size
            cbar.ax.yaxis.set_tick_params(pad=self.cb_axis_labelpad, labelsize=self.cb_ticklabelsize)

            # Colorbar title
            if self.cb_orientation == &#39;vertical&#39;:
                if not isinstance(self.cb_title,
                                  type(None)) and self.cb_y_title is False and self.cb_top_title is False:
                    print(&#39;Input colorbar title location with booleans: cb_y_title=True or cb_top_title=True&#39;)
                if self.cb_y_title is True:
                    cbar.ax.set_ylabel(self.cb_title, rotation=self.cb_title_rotation,
                                       labelpad=self.cb_ytitle_labelpad)
                    text = cbar.ax.yaxis.label
                    font = mpl.font_manager.FontProperties(family=self.font, style=self.cb_title_style,
                                                           size=self.cb_title_size + self.font_size_increase,
                                                           weight=self.cb_title_weight)
                    text.set_font_properties(font)
                if self.cb_top_title is True:
                    cbar.ax.set_title(self.cb_title, rotation=self.cb_title_rotation,
                                      fontdict={&#39;verticalalignment&#39;: &#39;baseline&#39;,
                                                &#39;horizontalalignment&#39;: &#39;left&#39;},
                                      pad=self.cb_top_title_pad)
                    cbar.ax.title.set_position((self.x_cb_top_title, self.cb_top_title_y))
                    text = cbar.ax.title
                    font = mpl.font_manager.FontProperties(family=self.font, style=self.cb_title_style,
                                                           weight=self.cb_title_weight,
                                                           size=self.cb_title + self.font_size_increase)
                    text.set_font_properties(font)
            elif self.cb_orientation == &#39;horizontal&#39;:
                cbar.ax.set_xlabel(self.cb_title, rotation=self.cb_title_rotation, labelpad=self.cb_ytitle_labelpad)
                text = cbar.ax.xaxis.label
                font = mpl.font_manager.FontProperties(family=self.font, style=self.cb_title_style,
                                                       size=self.cb_title_size + self.font_size_increase,
                                                       weight=self.cb_title_weight)
                text.set_font_properties(font)

            # Outline
            cbar.outline.set_edgecolor(self.workspace_color2)
            cbar.outline.set_linewidth(self.cb_outline_width)

    def method_legend(self):
        if self.legend is True:
            lines_labels = [ax.get_legend_handles_labels() for ax in self.fig.axes]
            lines, labels = [sum(lol, []) for lol in zip(*lines_labels)]
            legend_font = font_manager.FontProperties(family=self.font,
                                                      weight=self.legend_weight,
                                                      style=self.legend_style,
                                                      size=self.legend_size + self.font_size_increase)
            self.legend = self.fig.legend(lines, labels,
                                          loc=self.legend_loc,
                                          bbox_to_anchor=self.legend_bbox_to_anchor, prop=legend_font,
                                          handleheight=self.legend_handleheight, ncol=self.legend_ncol)

    def method_resize_axes(self):

        # Bound definition
        if not isinstance(self.x_bounds, type(None)):
            if not isinstance(self.x_bounds[0], type(None)):
                self.x_lower_bound = self.x_bounds[0]
            if not isinstance(self.x_bounds[1], type(None)):
                self.x_upper_bound = self.x_bounds[1]
        if not isinstance(self.y_bounds, type(None)):
            if not isinstance(self.y_bounds[0], type(None)):
                self.y_lower_bound = self.y_bounds[0]
            if not isinstance(self.y_bounds[1], type(None)):
                self.y_upper_bound = self.y_bounds[1]

        if self.resize_axes is True:

            def bounds(d, u, l, up, lp, v):
                # Upper and lower bounds
                if isinstance(u, type(None)):
                    u = d.max()
                else:
                    up = 0
                if isinstance(l, type(None)):
                    l = d.min()
                else:
                    lp = 0
                # Bounds vector
                if isinstance(v, type(None)):
                    v = [self.x_lower_bound, self.x_upper_bound]
                if isinstance(v[0], type(None)):
                    v[0] = l
                if isinstance(v[1], type(None)):
                    v[1] = u
                return v, up, lp

            self.x_bounds, self.x_upper_resize_pad, self.x_lower_resize_pad = bounds(self.x,
                                                                                     self.x_upper_bound,
                                                                                     self.x_lower_bound,
                                                                                     self.x_upper_resize_pad,
                                                                                     self.x_lower_resize_pad,
                                                                                     self.x_bounds)
            self.y_bounds, self.y_upper_resize_pad, self.y_lower_resize_pad = bounds(self.y,
                                                                                     self.y_upper_bound,
                                                                                     self.y_lower_bound,
                                                                                     self.y_upper_resize_pad,
                                                                                     self.y_lower_resize_pad,
                                                                                     self.y_bounds)

            # Room to breathe
            if self.demo_pad_plot is True:
                pad_x = 0.05 * (abs(self.x + self.x.min()).max() - abs(self.x + self.x.min()).min())
                self.x_upper_resize_pad = pad_x
                self.x_lower_resize_pad = pad_x
                pad_y = 0.05 * (abs(self.y + self.y.min()).max() - abs(self.y + self.y.min()).min())
                self.y_upper_resize_pad = pad_y
                self.y_lower_resize_pad = pad_y

            # Allow constant input and single coordinate plots
            # Single coordinate plots
            if span(self.x_bounds) == 0 and span(self.y_bounds) == 0:
                # x bounds
                self.x_bounds = [self.x - self.x/2, self.x + self.x/2]
                self.x_upper_resize_pad = 0
                self.x_lower_resize_pad = 0
                # y bounds
                self.y_bounds = [self.y - self.y/2, self.y + self.y/2]
                self.y_upper_resize_pad = 0
                self.y_lower_resize_pad = 0
            # Constant x coordinate plot
            elif span(self.x_bounds) == 0:
                self.x_bounds = [self.x[0] - span(self.y)/2, self.x[0] + span(self.y)/2]
                self.x_upper_resize_pad = self.y_upper_resize_pad
                self.x_lower_resize_pad = self.y_lower_resize_pad
            # Constant y coordinate plot
            elif span(self.y_bounds) == 0:
                self.y_bounds = [self.y[0] - span(self.x)/2, self.y[0] + span(self.x)/2]
                self.y_upper_resize_pad = self.x_upper_resize_pad
                self.y_lower_resize_pad = self.x_lower_resize_pad

            # Set bounds
            self.ax.set_xbound(lower=self.x_bounds[0] - self.x_lower_resize_pad,
                               upper=self.x_bounds[1] + self.x_upper_resize_pad)
            self.ax.set_ybound(lower=self.y_bounds[0] - self.y_lower_resize_pad,
                               upper=self.y_bounds[1] + self.y_upper_resize_pad)

            self.ax.set_xlim(self.x_bounds[0] - self.x_lower_resize_pad,
                             self.x_bounds[1] + self.x_upper_resize_pad)
            self.ax.set_ylim(self.y_bounds[0] - self.y_lower_resize_pad,
                             self.y_bounds[1] + self.y_upper_resize_pad)

            # Aspect ratio
            if not isinstance(self.aspect, type(None)) and span(self.x_bounds) != 0 and span(self.y_bounds) != 0:
                y_range = span(self.y_bounds)
                x_range = span(self.x_bounds)

                aspect = x_range/y_range * self.aspect

                self.ax.set_aspect(aspect)

            # Scale
            if not isinstance(self.scale, type(None)):
                self.ax.set_aspect(self.scale)

    def method_title(self):
        if not isinstance(self.title, type(None)):
            self.ax.set_title(self.title,
                              fontname=self.font if isinstance(self.title_font, type(None)) else self.title_font,
                              weight=self.title_weight,
                              color=self.title_color if not isinstance(self.title_color, type(None))
                                    else self.font_color if not isinstance(self.font_color, type(None))
                                    else self.workspace_color,
                              size=self.title_size + self.font_size_increase)
            self.ax.title.set_position((0.5, self.title_y))

    def method_axis_labels(self):
        if not isinstance(self.x_label, type(None)):

            # Draw label
            self.ax.set_xlabel(self.x_label, fontname=self.font, weight=self.x_label_weight,
                               color=self.workspace_color if self.font_color == self.workspace_color else self.font_color,
                               size=self.x_label_size + self.font_size_increase, labelpad=self.x_label_pad,
                               rotation=self.x_label_rotation)

            # Custom coordinates if provided
            if not isinstance(self.x_label_coords, type(None)):
                self.ax.xaxis.set_label_coords(x=self.x_label_coords[0], y=self.x_label_coords[1])

        if not isinstance(self.y_label, type(None)):

            # y axis label rotation
            if isinstance(self.y_label_rotation, type(None)):
                self.y_label_rotation = 90 if len(self.y_label) &gt; 3 else 0

            # Draw label
            self.ax.set_ylabel(self.y_label, fontname=self.font, weight=self.y_label_weight,
                               color=self.workspace_color if self.font_color == self.workspace_color else self.font_color,
                               size=self.y_label_size + self.font_size_increase, labelpad=self.y_label_pad,
                               rotation=self.y_label_rotation)

            # Custom coordinates if provided
            if not isinstance(self.y_label_coords, type(None)):
                self.ax.yaxis.set_label_coords(x=self.y_label_coords[0], y=self.y_label_coords[1])

    def method_spines(self):
        for spine in self.ax.spines.values():
            spine.set_color(self.workspace_color if isinstance(self.spine_color, type(None)) else self.spine_color)

        if not isinstance(self.spines_removed, type(None)):
            for i in range(len(self.spines_removed)):
                if self.spines_removed[i] == 1:
                    self.ax.spines[[&#34;left&#34;, &#34;bottom&#34;, &#34;top&#34;, &#34;right&#34;][i]].set_visible(False)

        # Axis ticks
        left, bottom, top, right = self.ticks_where
        # Tick labels
        labelleft, labelbottom, labeltop, labelright = self.tick_labels_where

        self.ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,
                            top=top, right=right, left=left, bottom=bottom,
                            labeltop=labeltop, labelright=labelright, labelleft=labelleft, labelbottom=labelbottom)

    def method_ticks(self):
        &#34;&#34;&#34;
        Defaults
        &#34;&#34;&#34;
        # Fine tick locations
        if not isinstance(self.y, type(None)):  # Avoid issues with arrays with span 0 (vertical or horizontal lines)
            if span(self.y) == 0:
                self.fine_tick_locations = False
        if self.fine_tick_locations is True:
            if not isinstance(self.x, type(None)) and isinstance(self.x_custom_tick_locations, type(None)):
                self.x_custom_tick_locations = [self.x.min(), self.x.max()]
            if not isinstance(self.y, type(None)) and isinstance(self.y_custom_tick_locations, type(None)):
                self.y_custom_tick_locations = [self.y.min(), self.y.max()]
        &#34;&#34;&#34;
        Checks
        &#34;&#34;&#34;
        # Custom tick labels
        if not isinstance(self.x_custom_tick_labels, type(None)):           # Ensure the number of ticks equals the
            if self.x_tick_number != len(self.x_custom_tick_labels):        # length of the list of custom tick
                self.x_tick_number = len(self.x_custom_tick_labels)         # labels.
        &#34;&#34;&#34;
        Implementation
        &#34;&#34;&#34;
        #   Tick-label distance
        self.ax.xaxis.set_tick_params(pad=0.1, direction=&#39;in&#39;)
        self.ax.yaxis.set_tick_params(pad=0.1, direction=&#39;in&#39;)
        #   Color
        if not isinstance(self.tick_color, type(None)):
            self.ax.tick_params(axis=&#39;both&#39;, color=self.tick_color)
        #   Label font and color
        for tick in self.ax.get_xticklabels():
            tick.set_fontname(self.font)
            tick.set_color(self.workspace_color if self.font_color == self.workspace_color else self.font_color)
        for tick in self.ax.get_yticklabels():
            tick.set_fontname(self.font)
            tick.set_color(self.workspace_color if self.font_color == self.workspace_color else self.font_color)
        #   Label size
        if not isinstance(self.x_tick_label_size, type(None)):
            self.ax.tick_params(axis=&#39;x&#39;, labelsize=self.x_tick_label_size + self.font_size_increase)
        elif not isinstance(self.tick_label_size, type(None)):
            self.ax.tick_params(axis=&#39;x&#39;, labelsize=self.tick_label_size + self.font_size_increase)
        if not isinstance(self.y_tick_label_size, type(None)):
            self.ax.tick_params(axis=&#39;y&#39;, labelsize=self.y_tick_label_size + self.font_size_increase)
        elif not isinstance(self.tick_label_size, type(None)):
            self.ax.tick_params(axis=&#39;y&#39;, labelsize=self.tick_label_size + self.font_size_increase)
        #   Custom tick positions
        if not isinstance(self.x_custom_tick_locations, type(None)):
            high = self.x_custom_tick_locations[0]
            low = self.x_custom_tick_locations[1]
            # Set usual ticks
            if self.x_tick_number &gt; 1:
                ticklocs = np.linspace(low, high, self.x_tick_number)
            # Special case: single tick
            else:
                ticklocs = np.array([low + (high - low)/2])
            self.ax.set_xticks(ticklocs)
        if not isinstance(self.y_custom_tick_locations, type(None)):
            high = self.y_custom_tick_locations[0]
            low = self.y_custom_tick_locations[1]
            # Set usual ticks
            if self.y_tick_number &gt; 1:
                ticklocs = np.linspace(low, high, self.y_tick_number)
            # Special case: single tick
            else:
                ticklocs = np.array([low + (high - low)/2])
            self.ax.set_yticks(ticklocs)
        #   Prune
        if not isinstance(self.prune, type(None)):
            self.ax.xaxis.set_major_locator(self.plt.MaxNLocator(prune=self.prune))
        if not isinstance(self.prune, type(None)):
            self.ax.yaxis.set_major_locator(self.plt.MaxNLocator(prune=self.prune))
        #   Float format
        x_decimals = self.tick_ndecimals if isinstance(self.x_tick_ndecimals, type(None)) \
            else self.x_tick_ndecimals
        y_decimals = self.tick_ndecimals if isinstance(self.y_tick_ndecimals, type(None)) \
            else self.y_tick_ndecimals
        float_format_x = &#39;%.&#39; + str(x_decimals) + &#39;f&#39;
        float_format_y = &#39;%.&#39; + str(y_decimals) + &#39;f&#39;
        self.ax.xaxis.set_major_formatter(FormatStrFormatter(float_format_x))
        self.ax.yaxis.set_major_formatter(FormatStrFormatter(float_format_y))
        #   Custom tick labels
        if not isinstance(self.x_custom_tick_labels, type(None)):
            if len(self.x_custom_tick_labels) == 2 and len(self.x_custom_tick_labels) != self.x_tick_number:
                self.x_custom_tick_labels = np.linspace(self.x_custom_tick_labels[0],
                                                        self.x_custom_tick_labels[1],
                                                        self.x_tick_number)
            self.ax.set_xticklabels(self.x_custom_tick_labels[::-1])
        if not isinstance(self.y_custom_tick_labels, type(None)):
            if len(self.y_custom_tick_labels) == 2 and len(self.y_custom_tick_labels) != self.y_tick_number:
                self.y_custom_tick_labels = np.linspace(self.y_custom_tick_labels[0],
                                                        self.y_custom_tick_labels[1],
                                                        self.y_tick_number)
            self.ax.set_yticklabels(self.y_custom_tick_labels[::-1])
        #       Date tick labels
        if self.x_date_tick_labels is True:
            fmtd = pd.date_range(start=self.x[0], end=self.x[-1], periods=self.x_tick_number)
            fmtd = [dt.datetime.strftime(d, self.date_format) for d in fmtd]
            self.ax.set_xticklabels(fmtd)
        #   Tick-label pad ---------------------------------------------------------------------------------------------
        if not isinstance(self.tick_label_pad, type(None)):
            self.ax.tick_params(axis=&#39;both&#39;, pad=self.tick_label_pad)
        #   Rotation
        if not isinstance(self.x_tick_rotation, type(None)):
            self.ax.tick_params(axis=&#39;x&#39;, rotation=self.x_tick_rotation)
            for tick in self.ax.xaxis.get_majorticklabels():
                tick.set_horizontalalignment(&#34;right&#34;)
        if not isinstance(self.y_tick_rotation, type(None)):
            self.ax.tick_params(axis=&#39;y&#39;, rotation=self.y_tick_rotation)
            for tick in self.ax.yaxis.get_majorticklabels():
                tick.set_horizontalalignment(&#34;left&#34;)


class plot(canvas, attributes):

    def init(self):

        self.method_backend()

        self.plt = import_module(&#34;matplotlib.pyplot&#34;)

        &#34;&#34;&#34;
        Run
        &#34;&#34;&#34;

        self.run()

    def run(self):
        self.main()
        try:
            self.custom()
        except AttributeError:
            pass
        self.finish()

    def main(self):
        # Canvas setup
        self.method_fonts()
        self.method_setup()
        self.method_grid()
        self.method_background_color()
        self.method_workspace_style()

        # Mock plot
        self.mock()

        # Plot
        self.plot()

        # Colorbar
        self.method_cb()

    def finish(self):
        # Makeup
        self.method_title()
        self.method_axis_labels()
        self.method_spines()
        self.method_ticks()

        # Save
        self.method_save()

        self.method_show()

    def method_save(self):
        if self.filename:
            self.plt.savefig(self.filename, dpi=self.dpi)

    def method_show(self):
        if self.show is True:
            self.fig.tight_layout()
            self.plt.show()
        else:
            if self.suppress is False:
                print(&#39;Ready for next subplot&#39;)


class std_input():

    def custom(self):
        # Resize axes
        self.method_resize_axes()
        # Legend
        self.method_legend()


class df_input:

    def method_resize_axes_dataframe(self):
        if self.resize_axes is True:
            xmin = 0
            ymin = 0
            xmax = self.z.shape[0]
            ymax = self.z.shape[1]
            if isinstance(self.x_upper_bound, type(None)):
                self.x_upper_bound = xmax
            if isinstance(self.x_lower_bound, type(None)):
                self.x_lower_bound = xmin
            if isinstance(self.y_upper_bound, type(None)):
                self.y_upper_bound = ymax
            if isinstance(self.y_lower_bound, type(None)):
                self.y_lower_bound = ymin

            if not isinstance(self.scale, type(None)):
                self.ax.set_aspect(self.scale)

            if not isinstance(self.aspect, type(None)):
                y_range = abs(ymax) + abs(ymin)
                x_range = abs(xmax) + abs(xmin)

                aspect = x_range/y_range * self.aspect

                self.ax.set_aspect(aspect)


class line(plot, std_input):

    def __init__(self,
                 # Specifics
                 x=None, y=None, line_width=2,
                 # Specifics: color
                 color=&#39;darkred&#39;, cmap=&#39;RdBu_r&#39;, alpha=None, norm=None,
                 # Backend
                 backend=&#39;Qt5Agg&#39;,
                 # Fonts
                 font=&#39;serif&#39;, math_font=&#34;dejavuserif&#34;, font_color=&#34;black&#34;, font_size_increase=0,
                 # Figure, axes
                 fig=None, ax=None, figsize=None, shape_and_position=111, prune=None, resize_axes=True,
                 scale=None, aspect=1,
                 # Setup
                 workspace_color=None, workspace_color2=None,
                 background_color_figure=&#39;white&#39;, background_color_plot=&#39;white&#39;, background_alpha=1,
                 style=None, light=None, dark=None,
                 # Spines
                 spine_color=None, spines_removed=(0, 0, 1, 1),
                 # Bounds
                 x_upper_bound=None, x_lower_bound=None,
                 y_upper_bound=None, y_lower_bound=None,
                 x_bounds=None, y_bounds=None,
                 # Pads
                 demo_pad_plot=False,
                 x_upper_resize_pad=0, x_lower_resize_pad=0,
                 y_upper_resize_pad=0, y_lower_resize_pad=0,
                 # Grid
                 grid=True, grid_color=&#39;lightgrey&#39;, grid_lines=&#39;-.&#39;,
                 # Title
                 title=None, title_size=12, title_y=1.025, title_weight=None, title_font=None, title_color=None,
                 # Labels
                 x_label=None, x_label_size=12, x_label_pad=10, x_label_rotation=None, x_label_weight=None,
                 y_label=None, y_label_size=12, y_label_pad=10, y_label_rotation=None, y_label_weight=None,
                 # Ticks
                 x_tick_number=5,
                 y_tick_number=5,
                 x_label_coords=None, y_label_coords=None,
                 tick_color=None, tick_label_pad=5,
                 ticks_where=(1, 1, 0, 0),
                 # Tick labels
                 tick_label_size=10, x_tick_label_size=None, y_tick_label_size=None,
                 x_custom_tick_locations=None, y_custom_tick_locations=None, fine_tick_locations=True,
                 x_custom_tick_labels=None, y_custom_tick_labels=None,
                 x_date_tick_labels=False, date_format=&#39;%Y-%m-%d&#39;,
                 tick_ndecimals=1, x_tick_ndecimals=None, y_tick_ndecimals=None,
                 x_tick_rotation=None, y_tick_rotation=None,
                 tick_labels_where=(1, 1, 0, 0),
                 # Color bar
                 color_bar=False, cb_pad=0.2, cb_axis_labelpad=10, shrink=0.75, extend=&#39;neither&#39;,
                 cb_title=None, cb_orientation=&#39;vertical&#39;,
                 cb_title_rotation=None, cb_title_style=&#39;normal&#39;, cb_title_size=10,
                 cb_top_title_y=1, cb_ytitle_labelpad=10, cb_title_weight=&#39;normal&#39;, cb_top_title=False,
                 cb_y_title=False, cb_top_title_pad=None, x_cb_top_title=0,
                 cb_vmin=None, cb_vmax=None, cb_hard_bounds=False, cb_outline_width=None,
                 cb_tick_number=5, cb_ticklabelsize=10, cb_tick_ndecimals=None,
                 # Legend
                 plot_label=None,
                 legend=False, legend_loc=&#39;upper right&#39;, legend_bbox_to_anchor=None,
                 legend_size=13, legend_weight=&#39;normal&#39;,
                 legend_style=&#39;normal&#39;, legend_handleheight=None, legend_ncol=1,
                 # Subplots
                 show=False, zorder=None,
                 # Save
                 filename=None, dpi=None,
                 # Suppress output
                 suppress=True
                 ):
        &#34;&#34;&#34;
        Line plot class
        mpl_plotter - 2D

        Specifics
        :param x: x
        :param y: y
        :param line_width: Line width

        Color:
        :param color: Solid color
        :param cmap: Colormap
        :param alpha: Alpha
        :param norm: Norm to assign colormap values

        Other
        :param backend: Interactive plotting backends. Working with Python 3.7.6: Qt5Agg, QT4Agg, TkAgg.
                        Backend error:
                            pip install pyqt5
                            pip install tkinter
                            pip install tk
                            ... stackoverflow
                        Plotting window freezes even if trying different backends with no backend error: python configuration problem
                            backend=None
        &#34;&#34;&#34;

        # Turn all instance arguments to instance attributes
        for item in inspect.signature(line).parameters:
            setattr(self, item, eval(item))

        self.init()

    def plot(self):

        if isinstance(self.norm, type(None)):
            self.graph = self.ax.plot(self.x, self.y, label=self.plot_label, linewidth=self.line_width,
                                      color=self.color,
                                      zorder=self.zorder,
                                      alpha=self.alpha,
                                      )
        else:
            # Create a set of line segments so that we can color them individually
            # This creates the points as a N x 1 x 2 array so that we can stack points
            # together easily to get the segments. The segments array for line collection
            # needs to be (numlines) x (points per line) x 2 (for x and y)
            points = np.array([self.x, self.y]).T.reshape(-1, 1, 2)
            segments = np.concatenate([points[:-1], points[1:]], axis=1)

            # Create a continuous norm to map from data points to colors
            _norm = self.norm(self.x) if hasattr(self.norm, &#39;__call__&#39;) else self.norm
            norm = self.plt.Normalize(_norm.min(), _norm.max())
            lc = mpl.collections.LineCollection(segments, cmap=self.cmap, norm=norm)

            # Set the values used for colormapping
            lc.set_array(self.norm)
            lc.set_linewidth(self.line_width)
            self.graph = self.ax.add_collection(lc)

    def mock(self):
        if isinstance(self.x, type(None)) and isinstance(self.y, type(None)):
            self.x, self.y = MockData().spirograph()
            if self.norm is True:
                self.norm = self.y


class scatter(plot, std_input):

    def __init__(self,
                 # Specifics
                 x=None, y=None, point_size=5, marker=&#39;o&#39;,
                 # Specifics: color
                 color=&#34;C0&#34;, cmap=&#39;RdBu_r&#39;, alpha=None, norm=None,
                 # Backend
                 backend=&#39;Qt5Agg&#39;,
                 # Fonts
                 font=&#39;serif&#39;, math_font=&#34;dejavuserif&#34;, font_color=&#34;black&#34;, font_size_increase=0,
                 # Figure, axes
                 fig=None, ax=None, figsize=None, shape_and_position=111, prune=None, resize_axes=True,
                 scale=None, aspect=1,
                 # Setup
                 workspace_color=None, workspace_color2=None,
                 background_color_figure=&#39;white&#39;, background_color_plot=&#39;white&#39;, background_alpha=1,
                 style=None, light=None, dark=None,
                 # Spines
                 spine_color=None, spines_removed=(0, 0, 1, 1),
                 # Bounds
                 x_upper_bound=None, x_lower_bound=None,
                 y_upper_bound=None, y_lower_bound=None,
                 x_bounds=None, y_bounds=None,
                 # Pads
                 demo_pad_plot=False,
                 x_upper_resize_pad=0, x_lower_resize_pad=0,
                 y_upper_resize_pad=0, y_lower_resize_pad=0,
                 # Grid
                 grid=True, grid_color=&#39;lightgrey&#39;, grid_lines=&#39;-.&#39;,
                 # Title
                 title=None, title_size=12, title_y=1.025, title_weight=None, title_font=None, title_color=None,
                 # Labels
                 x_label=None, x_label_size=12, x_label_pad=10, x_label_rotation=None, x_label_weight=None,
                 y_label=None, y_label_size=12, y_label_pad=10, y_label_rotation=None, y_label_weight=None,
                 # Ticks
                 x_tick_number=5,
                 y_tick_number=5,
                 x_label_coords=None, y_label_coords=None,
                 tick_color=None, tick_label_pad=5,
                 ticks_where=(1, 1, 0, 0),
                 # Tick labels
                 tick_label_size=10, x_tick_label_size=None, y_tick_label_size=None,
                 x_custom_tick_locations=None, y_custom_tick_locations=None, fine_tick_locations=True,
                 x_custom_tick_labels=None, y_custom_tick_labels=None,
                 x_date_tick_labels=False, date_format=&#39;%Y-%m-%d&#39;,
                 tick_ndecimals=1, x_tick_ndecimals=None, y_tick_ndecimals=None,
                 x_tick_rotation=None, y_tick_rotation=None,
                 tick_labels_where=(1, 1, 0, 0),
                 # Color bar
                 color_bar=False, cb_pad=0.2, cb_axis_labelpad=10, shrink=0.75, extend=&#39;neither&#39;,
                 cb_title=None, cb_orientation=&#39;vertical&#39;,
                 cb_title_rotation=None, cb_title_style=&#39;normal&#39;, cb_title_size=10,
                 cb_top_title_y=1, cb_ytitle_labelpad=10, cb_title_weight=&#39;normal&#39;, cb_top_title=False,
                 cb_y_title=False, cb_top_title_pad=None, x_cb_top_title=0,
                 cb_vmin=None, cb_vmax=None, cb_hard_bounds=False, cb_outline_width=None,
                 cb_tick_number=5, cb_ticklabelsize=10, cb_tick_ndecimals=None,
                 # Legend
                 plot_label=None,
                 legend=False, legend_loc=&#39;upper right&#39;, legend_bbox_to_anchor=None,
                 legend_size=13, legend_weight=&#39;normal&#39;,
                 legend_style=&#39;normal&#39;, legend_handleheight=None, legend_ncol=1,
                 # Subplots
                 show=False, zorder=None,
                 # Save
                 filename=None, dpi=None,
                 # Suppress output
                 suppress=True
                 ):
        &#34;&#34;&#34;
        Scatter plot class
        mpl_plotter - 2D

        Specifics
        :param x: x
        :param y: y
        :param point_size: Point size
        :param marker: Dot marker

        Color:
        :param color: Solid color
        :param cmap: Colormap
        :param alpha: Alpha
        :param norm: Norm to assign colormap values

        Other
        :param backend: Interactive plotting backends. Working with Python 3.7.6: Qt5Agg, QT4Agg, TkAgg.
                        Backend error:
                            pip install pyqt5
                            pip install tkinter
                            pip install tk
                            ... stackoverflow
                        Plotting window freezes even if trying different backends with no backend error: python configuration problem
                            backend=None
        &#34;&#34;&#34;

        # Turn all instance arguments to instance attributes
        for item in inspect.signature(scatter).parameters:
            setattr(self, item, eval(item))

        self.init()

    def plot(self):

        if not isinstance(self.norm, type(None)):
            self.graph = self.ax.scatter(self.x, self.y, label=self.plot_label, s=self.point_size, marker=self.marker,
                                         c=self.norm, cmap=self.cmap,
                                         zorder=self.zorder,
                                         alpha=self.alpha)
        else:
            self.graph = self.ax.scatter(self.x, self.y, label=self.plot_label, s=self.point_size, marker=self.marker,
                                         color=self.color,
                                         zorder=self.zorder,
                                         alpha=self.alpha)

    def mock(self):
        if isinstance(self.x, type(None)) and isinstance(self.y, type(None)):
            self.x, self.y = MockData().spirograph()
            self.norm = self.y


class heatmap(plot, df_input):

    def __init__(self,
                 # Specifics
                 x=None, y=None, z=None, normvariant=&#39;SymLog&#39;,
                 # Specifics: color
                 color=None, cmap=&#39;RdBu_r&#39;, alpha=None, norm=None,
                 # Backend
                 backend=&#39;Qt5Agg&#39;,
                 # Fonts
                 font=&#39;serif&#39;, math_font=&#34;dejavuserif&#34;, font_color=&#34;black&#34;, font_size_increase=0,
                 # Figure, axes
                 fig=None, ax=None, figsize=None, shape_and_position=111, prune=None, resize_axes=True,
                 scale=None, aspect=1,
                 # Setup
                 workspace_color=None, workspace_color2=None,
                 background_color_figure=&#39;white&#39;, background_color_plot=&#39;white&#39;, background_alpha=1,
                 style=None, light=None, dark=None,
                 # Spines
                 spine_color=None, spines_removed=(0, 0, 1, 1),
                 # Bounds
                 x_upper_bound=None, x_lower_bound=None,
                 y_upper_bound=None, y_lower_bound=None,
                 x_bounds=None, y_bounds=None,
                 # Pads
                 demo_pad_plot=False,
                 x_upper_resize_pad=0, x_lower_resize_pad=0,
                 y_upper_resize_pad=0, y_lower_resize_pad=0,
                 # Grid
                 grid=True, grid_color=&#39;lightgrey&#39;, grid_lines=&#39;-.&#39;,
                 # Title
                 title=None, title_size=12, title_y=1.025, title_weight=None, title_font=None, title_color=None,
                 # Labels
                 x_label=None, x_label_size=12, x_label_pad=10, x_label_rotation=None, x_label_weight=None,
                 y_label=None, y_label_size=12, y_label_pad=10, y_label_rotation=None, y_label_weight=None,
                 # Ticks
                 x_tick_number=5,
                 y_tick_number=5,
                 x_label_coords=None, y_label_coords=None,
                 tick_color=None, tick_label_pad=5,
                 ticks_where=(1, 1, 0, 0),
                 # Tick labels
                 tick_label_size=10, x_tick_label_size=None, y_tick_label_size=None,
                 x_custom_tick_locations=None, y_custom_tick_locations=None, fine_tick_locations=True,
                 x_custom_tick_labels=None, y_custom_tick_labels=None,
                 x_date_tick_labels=False, date_format=&#39;%Y-%m-%d&#39;,
                 tick_ndecimals=1, x_tick_ndecimals=None, y_tick_ndecimals=None,
                 x_tick_rotation=None, y_tick_rotation=None,
                 tick_labels_where=(1, 1, 0, 0),
                 # Color bar
                 color_bar=False, cb_pad=0.2, cb_axis_labelpad=10, shrink=0.75, extend=&#39;neither&#39;,
                 cb_title=None, cb_orientation=&#39;vertical&#39;,
                 cb_title_rotation=None, cb_title_style=&#39;normal&#39;, cb_title_size=10,
                 cb_top_title_y=1, cb_ytitle_labelpad=10, cb_title_weight=&#39;normal&#39;, cb_top_title=False,
                 cb_y_title=False, cb_top_title_pad=None, x_cb_top_title=0,
                 cb_vmin=None, cb_vmax=None, cb_hard_bounds=False, cb_outline_width=None,
                 cb_tick_number=5, cb_ticklabelsize=10, cb_tick_ndecimals=None,
                 # Legend
                 plot_label=None,
                 legend=False, legend_loc=&#39;upper right&#39;, legend_bbox_to_anchor=None,
                 legend_size=13, legend_weight=&#39;normal&#39;,
                 legend_style=&#39;normal&#39;, legend_handleheight=None, legend_ncol=1,
                 # Subplots
                 show=False, zorder=None,
                 # Save
                 filename=None, dpi=None,
                 # Suppress output
                 suppress=True
                 ):
        &#34;&#34;&#34;
        Heatmap plot class
        mpl_plotter - 2D

        Specifics
        :param x: x
        :param y: y
        :param z: z
        :param normvariant: Detailed information in the Matplotlib documentation

        Color:
        :param color: Solid color
        :param cmap: Colormap
        :param alpha: Alpha
        :param norm: Norm to assign colormap values

        Other
        :param backend: Interactive plotting backends. Working with Python 3.7.6: Qt5Agg, QT4Agg, TkAgg.
                        Backend error:
                            pip install pyqt5
                            pip install tkinter
                            pip install tk
                            ... stackoverflow
                        Plotting window freezes even if trying different backends with no backend error: python configuration problem
                            backend=None
        &#34;&#34;&#34;
        # Turn all instance arguments to instance attributes
        for item in inspect.signature(heatmap).parameters:
            setattr(self, item, eval(item))

        self.init()

    def plot(self):

        if not isinstance(self.x, type(None)) and not isinstance(self.y, type(None)):
            self.graph = self.ax.pcolormesh(self.x, self.y, self.z, cmap=self.cmap,
                                            zorder=self.zorder,
                                            alpha=self.alpha,
                                            label=self.plot_label,
                                            )
            # Resize axes
            self.method_resize_axes()

        else:
            self.graph = self.ax.pcolormesh(self.z, cmap=self.cmap, norm=self.norm,
                                            zorder=self.zorder,
                                            alpha=self.alpha,
                                            label=self.plot_label, )
            # Resize axes
            self.method_resize_axes_dataframe()

    def mock(self):
        if isinstance(self.x, type(None)) and isinstance(self.y, type(None)):
            self.z = MockData().waterdropdf()


class quiver(plot, std_input):

    def __init__(self,
                 # Specifics
                 x=None, y=None, u=None, v=None,
                 # Specifics: color
                 color=None, cmap=&#39;RdBu_r&#39;, alpha=None, norm=None,
                 rule=None, custom_rule=None, vector_width=0.01, vector_min_shaft=2, vector_length_threshold=0.1,
                 # Backend
                 backend=&#39;Qt5Agg&#39;,
                 # Fonts
                 font=&#39;serif&#39;, math_font=&#34;dejavuserif&#34;, font_color=&#34;black&#34;, font_size_increase=0,
                 # Figure, axes
                 fig=None, ax=None, figsize=None, shape_and_position=111, prune=None, resize_axes=True,
                 scale=None, aspect=1,
                 # Setup
                 workspace_color=None, workspace_color2=None,
                 background_color_figure=&#39;white&#39;, background_color_plot=&#39;white&#39;, background_alpha=1,
                 style=None, light=None, dark=None,
                 # Spines
                 spine_color=None, spines_removed=(0, 0, 1, 1),
                 # Bounds
                 x_upper_bound=None, x_lower_bound=None,
                 y_upper_bound=None, y_lower_bound=None,
                 x_bounds=None, y_bounds=None,
                 # Pads
                 demo_pad_plot=False,
                 x_upper_resize_pad=0, x_lower_resize_pad=0,
                 y_upper_resize_pad=0, y_lower_resize_pad=0,
                 # Grid
                 grid=True, grid_color=&#39;lightgrey&#39;, grid_lines=&#39;-.&#39;,
                 # Title
                 title=None, title_size=12, title_y=1.025, title_weight=None, title_font=None, title_color=None,
                 # Labels
                 x_label=None, x_label_size=12, x_label_pad=10, x_label_rotation=None, x_label_weight=None,
                 y_label=None, y_label_size=12, y_label_pad=10, y_label_rotation=None, y_label_weight=None,
                 # Ticks
                 x_tick_number=5,
                 y_tick_number=5,
                 x_label_coords=None, y_label_coords=None,
                 tick_color=None, tick_label_pad=5,
                 ticks_where=(1, 1, 0, 0),
                 # Tick labels
                 tick_label_size=10, x_tick_label_size=None, y_tick_label_size=None,
                 x_custom_tick_locations=None, y_custom_tick_locations=None, fine_tick_locations=True,
                 x_custom_tick_labels=None, y_custom_tick_labels=None,
                 x_date_tick_labels=False, date_format=&#39;%Y-%m-%d&#39;,
                 tick_ndecimals=1, x_tick_ndecimals=None, y_tick_ndecimals=None,
                 x_tick_rotation=None, y_tick_rotation=None,
                 tick_labels_where=(1, 1, 0, 0),
                 # Color bar
                 color_bar=False, cb_pad=0.2, cb_axis_labelpad=10, shrink=0.75, extend=&#39;neither&#39;,
                 cb_title=None, cb_orientation=&#39;vertical&#39;,
                 cb_title_rotation=None, cb_title_style=&#39;normal&#39;, cb_title_size=10,
                 cb_top_title_y=1, cb_ytitle_labelpad=10, cb_title_weight=&#39;normal&#39;, cb_top_title=False,
                 cb_y_title=False, cb_top_title_pad=None, x_cb_top_title=0,
                 cb_vmin=None, cb_vmax=None, cb_hard_bounds=False, cb_outline_width=None,
                 cb_tick_number=5, cb_ticklabelsize=10, cb_tick_ndecimals=None,
                 # Legend
                 plot_label=None,
                 legend=False, legend_loc=&#39;upper right&#39;, legend_bbox_to_anchor=None,
                 legend_size=13, legend_weight=&#39;normal&#39;,
                 legend_style=&#39;normal&#39;, legend_handleheight=None, legend_ncol=1,
                 # Subplots
                 show=False, zorder=None,
                 # Save
                 filename=None, dpi=None,
                 # Suppress output
                 suppress=True
                 ):
        &#34;&#34;&#34;
        Quiver plot class
        mpl_plotter - 2D

        Specifics
        :param x: x
        :param y: y
        :param u: u
        :param v: v
        :param rule:  lambda function of u and v
            rule = lambda u, v: (u**2+v**2)
        :param custom_rule: Array assigning a color to each (x, y, u, v) vector
        :param vector_width: Vector width
        :param vector_min_shaft: Minimum vector shaft
        :param vector_length_threshold: Minimum vector length

        Color:
        :param color: Solid color
        :param cmap: Colormap
        :param alpha: Alpha
        :param norm: Norm to assign colormap values

        Other
        :param backend: Interactive plotting backends. Working with Python 3.7.6: Qt5Agg, QT4Agg, TkAgg.
                        Backend error:
                            pip install pyqt5
                            pip install tkinter
                            pip install tk
                            ... stackoverflow
                        Plotting window freezes even if trying different backends with no backend error: python configuration problem
                            backend=None
        &#34;&#34;&#34;
        # Turn all instance arguments to instance attributes
        for item in inspect.signature(quiver).parameters:
            setattr(self, item, eval(item))

        self.init()

    def plot(self):

        # Color rule
        self.method_rule()

        self.graph = self.ax.quiver(self.x, self.y, self.u, self.v,
                                    color=self.color, cmap=self.cmap,
                                    width=self.vector_width,
                                    minshaft=self.vector_min_shaft,
                                    minlength=self.vector_length_threshold,
                                    label=self.plot_label,
                                    zorder=self.zorder,
                                    alpha=self.alpha
                                    )

    def mock(self):
        if isinstance(self.x, type(None)) and isinstance(self.y, type(None)):
            self.x = np.random.random(100)
            self.y = np.random.random(100)
            self.u = np.random.random(100)
            self.v = np.random.random(100)
            self.norm = np.sqrt(self.u ** 2 + self.v ** 2)

    def method_rule(self):
        # Rule
        if isinstance(self.custom_rule, type(None)):
            if isinstance(self.rule, type(None)):
                self.rule = lambda u, v: (u ** 2 + v ** 2)
            self.rule = self.rule(u=self.u, v=self.v)
        else:
            self.rule = self.custom_rule

        # Color determined by rule function
        c = self.rule
        # Flatten and normalize
        c = (c.ravel() - c.min())/c.ptp()
        # Repeat for each body line and two head lines
        c = np.concatenate((c, np.repeat(c, 2)))
        # Colormap
        cmap = mpl.cm.get_cmap(self.cmap)
        self.color = cmap(c)


class streamline(plot, std_input):

    def __init__(self,
                 # Specifics
                 x=None, y=None, u=None, v=None, line_width=1, line_density=2,
                 # Specifics: color
                 color=None, cmap=&#39;RdBu_r&#39;, alpha=None, norm=None,
                 # Backend
                 backend=&#39;Qt5Agg&#39;,
                 # Fonts
                 font=&#39;serif&#39;, math_font=&#34;dejavuserif&#34;, font_color=&#34;black&#34;, font_size_increase=0,
                 # Figure, axes
                 fig=None, ax=None, figsize=None, shape_and_position=111, prune=None, resize_axes=True,
                 scale=None, aspect=1,
                 # Setup
                 workspace_color=None, workspace_color2=None,
                 background_color_figure=&#39;white&#39;, background_color_plot=&#39;white&#39;, background_alpha=1,
                 style=None, light=None, dark=None,
                 # Spines
                 spine_color=None, spines_removed=(0, 0, 1, 1),
                 # Bounds
                 x_upper_bound=None, x_lower_bound=None,
                 y_upper_bound=None, y_lower_bound=None,
                 x_bounds=None, y_bounds=None,
                 # Pads
                 demo_pad_plot=False,
                 x_upper_resize_pad=0, x_lower_resize_pad=0,
                 y_upper_resize_pad=0, y_lower_resize_pad=0,
                 # Grid
                 grid=True, grid_color=&#39;lightgrey&#39;, grid_lines=&#39;-.&#39;,
                 # Title
                 title=None, title_size=12, title_y=1.025, title_weight=None, title_font=None, title_color=None,
                 # Labels
                 x_label=None, x_label_size=12, x_label_pad=10, x_label_rotation=None, x_label_weight=None,
                 y_label=None, y_label_size=12, y_label_pad=10, y_label_rotation=None, y_label_weight=None,
                 # Ticks
                 x_tick_number=5,
                 y_tick_number=5,
                 x_label_coords=None, y_label_coords=None,
                 tick_color=None, tick_label_pad=5,
                 ticks_where=(1, 1, 0, 0),
                 # Tick labels
                 tick_label_size=10, x_tick_label_size=None, y_tick_label_size=None,
                 x_custom_tick_locations=None, y_custom_tick_locations=None, fine_tick_locations=True,
                 x_custom_tick_labels=None, y_custom_tick_labels=None,
                 x_date_tick_labels=False, date_format=&#39;%Y-%m-%d&#39;,
                 tick_ndecimals=1, x_tick_ndecimals=None, y_tick_ndecimals=None,
                 x_tick_rotation=None, y_tick_rotation=None,
                 tick_labels_where=(1, 1, 0, 0),
                 # Color bar
                 color_bar=False, cb_pad=0.2, cb_axis_labelpad=10, shrink=0.75, extend=&#39;neither&#39;,
                 cb_title=None, cb_orientation=&#39;vertical&#39;,
                 cb_title_rotation=None, cb_title_style=&#39;normal&#39;, cb_title_size=10,
                 cb_top_title_y=1, cb_ytitle_labelpad=10, cb_title_weight=&#39;normal&#39;, cb_top_title=False,
                 cb_y_title=False, cb_top_title_pad=None, x_cb_top_title=0,
                 cb_vmin=None, cb_vmax=None, cb_hard_bounds=False, cb_outline_width=None,
                 cb_tick_number=5, cb_ticklabelsize=10, cb_tick_ndecimals=None,
                 # Legend
                 plot_label=None,
                 legend=False, legend_loc=&#39;upper right&#39;, legend_bbox_to_anchor=None,
                 legend_size=13, legend_weight=&#39;normal&#39;,
                 legend_style=&#39;normal&#39;, legend_handleheight=None, legend_ncol=1,
                 # Subplots
                 show=False, zorder=None,
                 # Save
                 filename=None, dpi=None,
                 # Suppress output
                 suppress=True
                 ):
        &#34;&#34;&#34;
        Streamline class
        mpl_plotter - 2D

        Specifics
        :param x: x
        :param y: y
        :param u: u
        :param v: v
        :param line_width: Streamline width
        :param line_density: Measure of the amount of streamlines displayed. Low value (default=2)


        Color:
        :param color: Solid color
        :param cmap: Colormap
        :param alpha: Alpha
        :param norm: Norm to assign colormap values

        Other
        :param backend: Interactive plotting backends. Working with Python 3.7.6: Qt5Agg, QT4Agg, TkAgg.
                        Backend error:
                            pip install pyqt5
                            pip install tkinter
                            pip install tk
                            ... stackoverflow
                        Plotting window freezes even if trying different backends with no backend error: python configuration problem
                            backend=None
        &#34;&#34;&#34;

        # Turn all instance arguments to instance attributes
        for item in inspect.signature(streamline).parameters:
            setattr(self, item, eval(item))

        self.init()

    def plot(self):

        # Color rule
        self.method_rule()

        # Plot
        self.graph = self.ax.streamplot(self.x, self.y, self.u, self.v,
                                        color=self.color,
                                        cmap=self.cmap,
                                        linewidth=self.line_width,
                                        density=self.line_density,
                                        zorder=self.zorder,
                                        ).lines

    def mock(self):
        if isinstance(self.x, type(None)) and isinstance(self.y, type(None)):
            self.x = np.linspace(0, 10, 100)
            self.y = np.linspace(0, 10, 100)
            self.x, self.y = np.meshgrid(self.x, self.y)
            self.u = np.cos(self.x)
            self.v = np.cos(self.y)
            self.color = self.u

    def method_rule(self):
        if isinstance(self.color, type(None)):
            rule_color = lambda u: np.sqrt(self.u ** 2 + self.v ** 2) / np.sqrt(self.u.max() ** 2 + self.v.max() ** 2)
            self.color = rule_color(self.u)


class fill_area(plot, std_input):

    def __init__(self,
                 # Specifics
                 x=None, y=None, z=None, between=False, below=False, above=False,
                 # Specifics: color
                 color=None, cmap=&#39;RdBu_r&#39;, alpha=None, norm=None,
                 # Backend
                 backend=&#39;Qt5Agg&#39;,
                 # Fonts
                 font=&#39;serif&#39;, math_font=&#34;dejavuserif&#34;, font_color=&#34;black&#34;, font_size_increase=0,
                 # Figure, axes
                 fig=None, ax=None, figsize=None, shape_and_position=111, prune=None, resize_axes=True,
                 scale=None, aspect=1,
                 # Setup
                 workspace_color=None, workspace_color2=None,
                 background_color_figure=&#39;white&#39;, background_color_plot=&#39;white&#39;, background_alpha=1,
                 style=None, light=None, dark=None,
                 # Spines
                 spine_color=None, spines_removed=(0, 0, 1, 1),
                 # Bounds
                 x_upper_bound=None, x_lower_bound=None,
                 y_upper_bound=None, y_lower_bound=None,
                 x_bounds=None, y_bounds=None,
                 # Pads
                 demo_pad_plot=False,
                 x_upper_resize_pad=0, x_lower_resize_pad=0,
                 y_upper_resize_pad=0, y_lower_resize_pad=0,
                 # Grid
                 grid=True, grid_color=&#39;lightgrey&#39;, grid_lines=&#39;-.&#39;,
                 # Title
                 title=None, title_size=12, title_y=1.025, title_weight=None, title_font=None, title_color=None,
                 # Labels
                 x_label=None, x_label_size=12, x_label_pad=10, x_label_rotation=None, x_label_weight=None,
                 y_label=None, y_label_size=12, y_label_pad=10, y_label_rotation=None, y_label_weight=None,
                 # Ticks
                 x_tick_number=5,
                 y_tick_number=5,
                 x_label_coords=None, y_label_coords=None,
                 tick_color=None, tick_label_pad=5,
                 ticks_where=(1, 1, 0, 0),
                 # Tick labels
                 tick_label_size=10, x_tick_label_size=None, y_tick_label_size=None,
                 x_custom_tick_locations=None, y_custom_tick_locations=None, fine_tick_locations=True,
                 x_custom_tick_labels=None, y_custom_tick_labels=None,
                 x_date_tick_labels=False, date_format=&#39;%Y-%m-%d&#39;,
                 tick_ndecimals=1, x_tick_ndecimals=None, y_tick_ndecimals=None,
                 x_tick_rotation=None, y_tick_rotation=None,
                 tick_labels_where=(1, 1, 0, 0),
                 # Color bar
                 color_bar=False, cb_pad=0.2, cb_axis_labelpad=10, shrink=0.75, extend=&#39;neither&#39;,
                 cb_title=None, cb_orientation=&#39;vertical&#39;,
                 cb_title_rotation=None, cb_title_style=&#39;normal&#39;, cb_title_size=10,
                 cb_top_title_y=1, cb_ytitle_labelpad=10, cb_title_weight=&#39;normal&#39;, cb_top_title=False,
                 cb_y_title=False, cb_top_title_pad=None, x_cb_top_title=0,
                 cb_vmin=None, cb_vmax=None, cb_hard_bounds=False, cb_outline_width=None,
                 cb_tick_number=5, cb_ticklabelsize=10, cb_tick_ndecimals=None,
                 # Legend
                 plot_label=None,
                 legend=False, legend_loc=&#39;upper right&#39;, legend_bbox_to_anchor=None,
                 legend_size=13, legend_weight=&#39;normal&#39;,
                 legend_style=&#39;normal&#39;, legend_handleheight=None, legend_ncol=1,
                 # Subplots
                 show=False, zorder=None,
                 # Save
                 filename=None, dpi=None,
                 # Suppress output
                 suppress=True
                 ):

        &#34;&#34;&#34;
        Fill area class
        mpl_plotter - 2D

        Specifics
        :param x: Horizontal axis values
        :param y: Curve 1
        :param z: Curve 2

        The following parameters can be used in combination:

        :param between: Fill between Curve 1 and Curve 2
        :param below: Fill below Curve 1 and Curve 2
        :param above: Fill above Curve 1 and Curve 2

        Color:
        :param color: Solid color
        :param cmap: Colormap
        :param alpha: Alpha
        :param norm: Norm to assign colormap values

        Other
        :param backend: Interactive plotting backends. Working with Python 3.7.6: Qt5Agg, QT4Agg, TkAgg.
                        Backend error:
                            pip install pyqt5
                            pip install tkinter
                            pip install tk
                            ... stackoverflow
                        Plotting window freezes even if trying different backends with no backend error: python configuration problem
                            backend=None
        &#34;&#34;&#34;

        # Turn all instance arguments to instance attributes
        for item in inspect.signature(fill_area).parameters:
            setattr(self, item, eval(item))

        self.init()

    def plot(self):

        &#34;&#34;&#34;
        Fill the region below the intersection of S and Z
        &#34;&#34;&#34;
        if not isinstance(self.z, type(None)):
            if self.between is True:
                self.ax.fill_between(self.x, self.y, self.z, facecolor=self.color,
                                     alpha=self.alpha, label=self.plot_label)
            if self.below is True:
                self.ax.fill_between(self.x, self.i_below(), np.zeros(self.y.shape), facecolor=self.color,
                                     alpha=self.alpha, label=self.plot_label)
            if self.above is True:
                self.ax.fill_between(self.x, self.i_above(), np.zeros(self.y.shape), facecolor=self.color,
                                     alpha=self.alpha, label=self.plot_label)
            if self.between is False and self.below is False and self.above is False:
                print_color(&#39;No area chosen to fill: specify whether to fill &#34;between&#34;, &#34;below&#34; or &#34;above&#34; the curves&#39;,
                            &#39;grey&#39;)
        else:
            self.ax.fill_between(self.x, self.y, np.zeros(self.y.shape), facecolor=self.color, alpha=self.alpha)

    def i_below(self):
        # Curve
        c = np.zeros(self.y.shape, dtype=float)
        for i in range(len(c)):
            c[i] = self.y[i] if self.y[i] &lt;= self.z[i] else self.z[i]
        return c

    def i_above(self):
        # Curve
        c = np.zeros(self.y.shape, dtype=float)
        for i in range(len(c)):
            c[i] = self.y[i] if self.y[i] &gt;= self.z[i] else self.z[i]
        return c

    def intersection(self):
        return np.nonzero(np.absolute(self.y - self.z) == min(np.absolute(self.y - self.z)))[0]

    def mock(self):
        if isinstance(self.x, type(None)) and isinstance(self.y, type(None)):
            self.x = np.arange(-6, 6, .01)
            self.y = MockData().boltzman(self.x, 0, 1)
            self.z = 1 - MockData().boltzman(self.x, 0.5, 1)
            line(fig=self.fig, ax=self.ax, x=self.x, y=self.y, color=&#39;darkred&#39;, line_width=2, grid=not self.grid,
                 plot_label=None, backend=self.backend)
            line(fig=self.fig, ax=self.ax, x=self.x, y=self.z, color=&#39;darkred&#39;, line_width=2, grid=not self.grid,
                 plot_label=None, backend=self.backend)
            self.below = True


def floating_text(ax, text, font=&#34;serif&#34;, x=0.5, y=0.5, size=20, weight=&#39;normal&#39;, color=&#39;darkred&#39;):
    # Font
    font = {&#39;family&#39;: font,
            &#39;color&#39;: color,
            &#39;weight&#39;: weight,
            &#39;size&#39;: size,
            }
    # Floating text
    ax.text(x, y, text, size=size, weight=weight, fontdict=font)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mpl_plotter.two_d.floating_text"><code class="name flex">
<span>def <span class="ident">floating_text</span></span>(<span>ax, text, font='serif', x=0.5, y=0.5, size=20, weight='normal', color='darkred')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def floating_text(ax, text, font=&#34;serif&#34;, x=0.5, y=0.5, size=20, weight=&#39;normal&#39;, color=&#39;darkred&#39;):
    # Font
    font = {&#39;family&#39;: font,
            &#39;color&#39;: color,
            &#39;weight&#39;: weight,
            &#39;size&#39;: size,
            }
    # Floating text
    ax.text(x, y, text, size=size, weight=weight, fontdict=font)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mpl_plotter.two_d.attributes"><code class="flex name class">
<span>class <span class="ident">attributes</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class attributes:

    def method_background_color(self):
        self.fig.patch.set_facecolor(self.background_color_figure)
        self.ax.set_facecolor(self.background_color_plot)
        self.ax.patch.set_alpha(self.background_alpha)

    def method_workspace_style(self):
        if self.light:
            self.workspace_color = &#39;black&#39; if isinstance(self.workspace_color, type(None)) else self.workspace_color
            self.workspace_color2 = (193/256, 193/256, 193/256) if isinstance(self.workspace_color2, type(
                None)) else self.workspace_color2
            self.style = &#39;classic&#39;
        elif self.dark:
            self.workspace_color = &#39;white&#39; if isinstance(self.workspace_color, type(None)) else self.workspace_color
            self.workspace_color2 = (89/256, 89/256, 89/256) if isinstance(self.workspace_color2,
                                                                                 type(
                                                                                     None)) else self.workspace_color2
            self.style = &#39;dark_background&#39;
        else:
            self.workspace_color = &#39;black&#39; if isinstance(self.workspace_color, type(None)) else self.workspace_color
            self.workspace_color2 = (193/256, 193/256, 193/256) if isinstance(self.workspace_color2, type(
                None)) else self.workspace_color2

    def method_cb(self):
        if self.color_bar is True:
            if isinstance(self.norm, type(None)):
                return print_color(&#34;No norm selected for colorbar. Set norm=&lt;parameter of choice&gt;&#34;, &#34;grey&#34;)

            # Obtain and apply limits
            if isinstance(self.cb_vmin, type(None)):
                self.cb_vmin = self.norm.min()
            if isinstance(self.cb_vmax, type(None)):
                self.cb_vmax = self.norm.max()
            self.graph.set_clim([self.cb_vmin, self.cb_vmax])

            # Normalization
            locator = np.linspace(self.cb_vmin, self.cb_vmax, self.cb_tick_number)

            # Colorbar
            cb_decimals = self.tick_ndecimals if isinstance(self.cb_tick_ndecimals, type(None)) \
                else self.cb_tick_ndecimals
            cbar = self.fig.colorbar(self.graph,
                                     ax=self.ax,
                                     # Add option to have different colormap and colorbar ranges
                                     norm=mpl.colors.Normalize(vmin=self.cb_vmin, vmax=self.cb_vmax),
                                     # Add option to have different colormap and colorbar ranges
                                     orientation=self.cb_orientation, shrink=self.shrink,
                                     ticks=locator,
                                     boundaries=locator if self.cb_hard_bounds is True else None,
                                     spacing=&#39;proportional&#39;,
                                     extend=self.extend,
                                     format=&#39;%.&#39; + str(cb_decimals) + &#39;f&#39;,
                                     pad=self.cb_pad,
                                     )

            # Ticks
            #   Locator
            cbar.locator = locator
            #   Direction
            cbar.ax.tick_params(axis=&#39;y&#39;, direction=&#39;out&#39;)
            #   Tick label pad and size
            cbar.ax.yaxis.set_tick_params(pad=self.cb_axis_labelpad, labelsize=self.cb_ticklabelsize)

            # Colorbar title
            if self.cb_orientation == &#39;vertical&#39;:
                if not isinstance(self.cb_title,
                                  type(None)) and self.cb_y_title is False and self.cb_top_title is False:
                    print(&#39;Input colorbar title location with booleans: cb_y_title=True or cb_top_title=True&#39;)
                if self.cb_y_title is True:
                    cbar.ax.set_ylabel(self.cb_title, rotation=self.cb_title_rotation,
                                       labelpad=self.cb_ytitle_labelpad)
                    text = cbar.ax.yaxis.label
                    font = mpl.font_manager.FontProperties(family=self.font, style=self.cb_title_style,
                                                           size=self.cb_title_size + self.font_size_increase,
                                                           weight=self.cb_title_weight)
                    text.set_font_properties(font)
                if self.cb_top_title is True:
                    cbar.ax.set_title(self.cb_title, rotation=self.cb_title_rotation,
                                      fontdict={&#39;verticalalignment&#39;: &#39;baseline&#39;,
                                                &#39;horizontalalignment&#39;: &#39;left&#39;},
                                      pad=self.cb_top_title_pad)
                    cbar.ax.title.set_position((self.x_cb_top_title, self.cb_top_title_y))
                    text = cbar.ax.title
                    font = mpl.font_manager.FontProperties(family=self.font, style=self.cb_title_style,
                                                           weight=self.cb_title_weight,
                                                           size=self.cb_title + self.font_size_increase)
                    text.set_font_properties(font)
            elif self.cb_orientation == &#39;horizontal&#39;:
                cbar.ax.set_xlabel(self.cb_title, rotation=self.cb_title_rotation, labelpad=self.cb_ytitle_labelpad)
                text = cbar.ax.xaxis.label
                font = mpl.font_manager.FontProperties(family=self.font, style=self.cb_title_style,
                                                       size=self.cb_title_size + self.font_size_increase,
                                                       weight=self.cb_title_weight)
                text.set_font_properties(font)

            # Outline
            cbar.outline.set_edgecolor(self.workspace_color2)
            cbar.outline.set_linewidth(self.cb_outline_width)

    def method_legend(self):
        if self.legend is True:
            lines_labels = [ax.get_legend_handles_labels() for ax in self.fig.axes]
            lines, labels = [sum(lol, []) for lol in zip(*lines_labels)]
            legend_font = font_manager.FontProperties(family=self.font,
                                                      weight=self.legend_weight,
                                                      style=self.legend_style,
                                                      size=self.legend_size + self.font_size_increase)
            self.legend = self.fig.legend(lines, labels,
                                          loc=self.legend_loc,
                                          bbox_to_anchor=self.legend_bbox_to_anchor, prop=legend_font,
                                          handleheight=self.legend_handleheight, ncol=self.legend_ncol)

    def method_resize_axes(self):

        # Bound definition
        if not isinstance(self.x_bounds, type(None)):
            if not isinstance(self.x_bounds[0], type(None)):
                self.x_lower_bound = self.x_bounds[0]
            if not isinstance(self.x_bounds[1], type(None)):
                self.x_upper_bound = self.x_bounds[1]
        if not isinstance(self.y_bounds, type(None)):
            if not isinstance(self.y_bounds[0], type(None)):
                self.y_lower_bound = self.y_bounds[0]
            if not isinstance(self.y_bounds[1], type(None)):
                self.y_upper_bound = self.y_bounds[1]

        if self.resize_axes is True:

            def bounds(d, u, l, up, lp, v):
                # Upper and lower bounds
                if isinstance(u, type(None)):
                    u = d.max()
                else:
                    up = 0
                if isinstance(l, type(None)):
                    l = d.min()
                else:
                    lp = 0
                # Bounds vector
                if isinstance(v, type(None)):
                    v = [self.x_lower_bound, self.x_upper_bound]
                if isinstance(v[0], type(None)):
                    v[0] = l
                if isinstance(v[1], type(None)):
                    v[1] = u
                return v, up, lp

            self.x_bounds, self.x_upper_resize_pad, self.x_lower_resize_pad = bounds(self.x,
                                                                                     self.x_upper_bound,
                                                                                     self.x_lower_bound,
                                                                                     self.x_upper_resize_pad,
                                                                                     self.x_lower_resize_pad,
                                                                                     self.x_bounds)
            self.y_bounds, self.y_upper_resize_pad, self.y_lower_resize_pad = bounds(self.y,
                                                                                     self.y_upper_bound,
                                                                                     self.y_lower_bound,
                                                                                     self.y_upper_resize_pad,
                                                                                     self.y_lower_resize_pad,
                                                                                     self.y_bounds)

            # Room to breathe
            if self.demo_pad_plot is True:
                pad_x = 0.05 * (abs(self.x + self.x.min()).max() - abs(self.x + self.x.min()).min())
                self.x_upper_resize_pad = pad_x
                self.x_lower_resize_pad = pad_x
                pad_y = 0.05 * (abs(self.y + self.y.min()).max() - abs(self.y + self.y.min()).min())
                self.y_upper_resize_pad = pad_y
                self.y_lower_resize_pad = pad_y

            # Allow constant input and single coordinate plots
            # Single coordinate plots
            if span(self.x_bounds) == 0 and span(self.y_bounds) == 0:
                # x bounds
                self.x_bounds = [self.x - self.x/2, self.x + self.x/2]
                self.x_upper_resize_pad = 0
                self.x_lower_resize_pad = 0
                # y bounds
                self.y_bounds = [self.y - self.y/2, self.y + self.y/2]
                self.y_upper_resize_pad = 0
                self.y_lower_resize_pad = 0
            # Constant x coordinate plot
            elif span(self.x_bounds) == 0:
                self.x_bounds = [self.x[0] - span(self.y)/2, self.x[0] + span(self.y)/2]
                self.x_upper_resize_pad = self.y_upper_resize_pad
                self.x_lower_resize_pad = self.y_lower_resize_pad
            # Constant y coordinate plot
            elif span(self.y_bounds) == 0:
                self.y_bounds = [self.y[0] - span(self.x)/2, self.y[0] + span(self.x)/2]
                self.y_upper_resize_pad = self.x_upper_resize_pad
                self.y_lower_resize_pad = self.x_lower_resize_pad

            # Set bounds
            self.ax.set_xbound(lower=self.x_bounds[0] - self.x_lower_resize_pad,
                               upper=self.x_bounds[1] + self.x_upper_resize_pad)
            self.ax.set_ybound(lower=self.y_bounds[0] - self.y_lower_resize_pad,
                               upper=self.y_bounds[1] + self.y_upper_resize_pad)

            self.ax.set_xlim(self.x_bounds[0] - self.x_lower_resize_pad,
                             self.x_bounds[1] + self.x_upper_resize_pad)
            self.ax.set_ylim(self.y_bounds[0] - self.y_lower_resize_pad,
                             self.y_bounds[1] + self.y_upper_resize_pad)

            # Aspect ratio
            if not isinstance(self.aspect, type(None)) and span(self.x_bounds) != 0 and span(self.y_bounds) != 0:
                y_range = span(self.y_bounds)
                x_range = span(self.x_bounds)

                aspect = x_range/y_range * self.aspect

                self.ax.set_aspect(aspect)

            # Scale
            if not isinstance(self.scale, type(None)):
                self.ax.set_aspect(self.scale)

    def method_title(self):
        if not isinstance(self.title, type(None)):
            self.ax.set_title(self.title,
                              fontname=self.font if isinstance(self.title_font, type(None)) else self.title_font,
                              weight=self.title_weight,
                              color=self.title_color if not isinstance(self.title_color, type(None))
                                    else self.font_color if not isinstance(self.font_color, type(None))
                                    else self.workspace_color,
                              size=self.title_size + self.font_size_increase)
            self.ax.title.set_position((0.5, self.title_y))

    def method_axis_labels(self):
        if not isinstance(self.x_label, type(None)):

            # Draw label
            self.ax.set_xlabel(self.x_label, fontname=self.font, weight=self.x_label_weight,
                               color=self.workspace_color if self.font_color == self.workspace_color else self.font_color,
                               size=self.x_label_size + self.font_size_increase, labelpad=self.x_label_pad,
                               rotation=self.x_label_rotation)

            # Custom coordinates if provided
            if not isinstance(self.x_label_coords, type(None)):
                self.ax.xaxis.set_label_coords(x=self.x_label_coords[0], y=self.x_label_coords[1])

        if not isinstance(self.y_label, type(None)):

            # y axis label rotation
            if isinstance(self.y_label_rotation, type(None)):
                self.y_label_rotation = 90 if len(self.y_label) &gt; 3 else 0

            # Draw label
            self.ax.set_ylabel(self.y_label, fontname=self.font, weight=self.y_label_weight,
                               color=self.workspace_color if self.font_color == self.workspace_color else self.font_color,
                               size=self.y_label_size + self.font_size_increase, labelpad=self.y_label_pad,
                               rotation=self.y_label_rotation)

            # Custom coordinates if provided
            if not isinstance(self.y_label_coords, type(None)):
                self.ax.yaxis.set_label_coords(x=self.y_label_coords[0], y=self.y_label_coords[1])

    def method_spines(self):
        for spine in self.ax.spines.values():
            spine.set_color(self.workspace_color if isinstance(self.spine_color, type(None)) else self.spine_color)

        if not isinstance(self.spines_removed, type(None)):
            for i in range(len(self.spines_removed)):
                if self.spines_removed[i] == 1:
                    self.ax.spines[[&#34;left&#34;, &#34;bottom&#34;, &#34;top&#34;, &#34;right&#34;][i]].set_visible(False)

        # Axis ticks
        left, bottom, top, right = self.ticks_where
        # Tick labels
        labelleft, labelbottom, labeltop, labelright = self.tick_labels_where

        self.ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,
                            top=top, right=right, left=left, bottom=bottom,
                            labeltop=labeltop, labelright=labelright, labelleft=labelleft, labelbottom=labelbottom)

    def method_ticks(self):
        &#34;&#34;&#34;
        Defaults
        &#34;&#34;&#34;
        # Fine tick locations
        if not isinstance(self.y, type(None)):  # Avoid issues with arrays with span 0 (vertical or horizontal lines)
            if span(self.y) == 0:
                self.fine_tick_locations = False
        if self.fine_tick_locations is True:
            if not isinstance(self.x, type(None)) and isinstance(self.x_custom_tick_locations, type(None)):
                self.x_custom_tick_locations = [self.x.min(), self.x.max()]
            if not isinstance(self.y, type(None)) and isinstance(self.y_custom_tick_locations, type(None)):
                self.y_custom_tick_locations = [self.y.min(), self.y.max()]
        &#34;&#34;&#34;
        Checks
        &#34;&#34;&#34;
        # Custom tick labels
        if not isinstance(self.x_custom_tick_labels, type(None)):           # Ensure the number of ticks equals the
            if self.x_tick_number != len(self.x_custom_tick_labels):        # length of the list of custom tick
                self.x_tick_number = len(self.x_custom_tick_labels)         # labels.
        &#34;&#34;&#34;
        Implementation
        &#34;&#34;&#34;
        #   Tick-label distance
        self.ax.xaxis.set_tick_params(pad=0.1, direction=&#39;in&#39;)
        self.ax.yaxis.set_tick_params(pad=0.1, direction=&#39;in&#39;)
        #   Color
        if not isinstance(self.tick_color, type(None)):
            self.ax.tick_params(axis=&#39;both&#39;, color=self.tick_color)
        #   Label font and color
        for tick in self.ax.get_xticklabels():
            tick.set_fontname(self.font)
            tick.set_color(self.workspace_color if self.font_color == self.workspace_color else self.font_color)
        for tick in self.ax.get_yticklabels():
            tick.set_fontname(self.font)
            tick.set_color(self.workspace_color if self.font_color == self.workspace_color else self.font_color)
        #   Label size
        if not isinstance(self.x_tick_label_size, type(None)):
            self.ax.tick_params(axis=&#39;x&#39;, labelsize=self.x_tick_label_size + self.font_size_increase)
        elif not isinstance(self.tick_label_size, type(None)):
            self.ax.tick_params(axis=&#39;x&#39;, labelsize=self.tick_label_size + self.font_size_increase)
        if not isinstance(self.y_tick_label_size, type(None)):
            self.ax.tick_params(axis=&#39;y&#39;, labelsize=self.y_tick_label_size + self.font_size_increase)
        elif not isinstance(self.tick_label_size, type(None)):
            self.ax.tick_params(axis=&#39;y&#39;, labelsize=self.tick_label_size + self.font_size_increase)
        #   Custom tick positions
        if not isinstance(self.x_custom_tick_locations, type(None)):
            high = self.x_custom_tick_locations[0]
            low = self.x_custom_tick_locations[1]
            # Set usual ticks
            if self.x_tick_number &gt; 1:
                ticklocs = np.linspace(low, high, self.x_tick_number)
            # Special case: single tick
            else:
                ticklocs = np.array([low + (high - low)/2])
            self.ax.set_xticks(ticklocs)
        if not isinstance(self.y_custom_tick_locations, type(None)):
            high = self.y_custom_tick_locations[0]
            low = self.y_custom_tick_locations[1]
            # Set usual ticks
            if self.y_tick_number &gt; 1:
                ticklocs = np.linspace(low, high, self.y_tick_number)
            # Special case: single tick
            else:
                ticklocs = np.array([low + (high - low)/2])
            self.ax.set_yticks(ticklocs)
        #   Prune
        if not isinstance(self.prune, type(None)):
            self.ax.xaxis.set_major_locator(self.plt.MaxNLocator(prune=self.prune))
        if not isinstance(self.prune, type(None)):
            self.ax.yaxis.set_major_locator(self.plt.MaxNLocator(prune=self.prune))
        #   Float format
        x_decimals = self.tick_ndecimals if isinstance(self.x_tick_ndecimals, type(None)) \
            else self.x_tick_ndecimals
        y_decimals = self.tick_ndecimals if isinstance(self.y_tick_ndecimals, type(None)) \
            else self.y_tick_ndecimals
        float_format_x = &#39;%.&#39; + str(x_decimals) + &#39;f&#39;
        float_format_y = &#39;%.&#39; + str(y_decimals) + &#39;f&#39;
        self.ax.xaxis.set_major_formatter(FormatStrFormatter(float_format_x))
        self.ax.yaxis.set_major_formatter(FormatStrFormatter(float_format_y))
        #   Custom tick labels
        if not isinstance(self.x_custom_tick_labels, type(None)):
            if len(self.x_custom_tick_labels) == 2 and len(self.x_custom_tick_labels) != self.x_tick_number:
                self.x_custom_tick_labels = np.linspace(self.x_custom_tick_labels[0],
                                                        self.x_custom_tick_labels[1],
                                                        self.x_tick_number)
            self.ax.set_xticklabels(self.x_custom_tick_labels[::-1])
        if not isinstance(self.y_custom_tick_labels, type(None)):
            if len(self.y_custom_tick_labels) == 2 and len(self.y_custom_tick_labels) != self.y_tick_number:
                self.y_custom_tick_labels = np.linspace(self.y_custom_tick_labels[0],
                                                        self.y_custom_tick_labels[1],
                                                        self.y_tick_number)
            self.ax.set_yticklabels(self.y_custom_tick_labels[::-1])
        #       Date tick labels
        if self.x_date_tick_labels is True:
            fmtd = pd.date_range(start=self.x[0], end=self.x[-1], periods=self.x_tick_number)
            fmtd = [dt.datetime.strftime(d, self.date_format) for d in fmtd]
            self.ax.set_xticklabels(fmtd)
        #   Tick-label pad ---------------------------------------------------------------------------------------------
        if not isinstance(self.tick_label_pad, type(None)):
            self.ax.tick_params(axis=&#39;both&#39;, pad=self.tick_label_pad)
        #   Rotation
        if not isinstance(self.x_tick_rotation, type(None)):
            self.ax.tick_params(axis=&#39;x&#39;, rotation=self.x_tick_rotation)
            for tick in self.ax.xaxis.get_majorticklabels():
                tick.set_horizontalalignment(&#34;right&#34;)
        if not isinstance(self.y_tick_rotation, type(None)):
            self.ax.tick_params(axis=&#39;y&#39;, rotation=self.y_tick_rotation)
            for tick in self.ax.yaxis.get_majorticklabels():
                tick.set_horizontalalignment(&#34;left&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpl_plotter.setup.custom_canvas2" href="setup.html#mpl_plotter.setup.custom_canvas2">custom_canvas2</a></li>
<li><a title="mpl_plotter.two_d.plot" href="#mpl_plotter.two_d.plot">plot</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mpl_plotter.two_d.attributes.method_axis_labels"><code class="name flex">
<span>def <span class="ident">method_axis_labels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_axis_labels(self):
    if not isinstance(self.x_label, type(None)):

        # Draw label
        self.ax.set_xlabel(self.x_label, fontname=self.font, weight=self.x_label_weight,
                           color=self.workspace_color if self.font_color == self.workspace_color else self.font_color,
                           size=self.x_label_size + self.font_size_increase, labelpad=self.x_label_pad,
                           rotation=self.x_label_rotation)

        # Custom coordinates if provided
        if not isinstance(self.x_label_coords, type(None)):
            self.ax.xaxis.set_label_coords(x=self.x_label_coords[0], y=self.x_label_coords[1])

    if not isinstance(self.y_label, type(None)):

        # y axis label rotation
        if isinstance(self.y_label_rotation, type(None)):
            self.y_label_rotation = 90 if len(self.y_label) &gt; 3 else 0

        # Draw label
        self.ax.set_ylabel(self.y_label, fontname=self.font, weight=self.y_label_weight,
                           color=self.workspace_color if self.font_color == self.workspace_color else self.font_color,
                           size=self.y_label_size + self.font_size_increase, labelpad=self.y_label_pad,
                           rotation=self.y_label_rotation)

        # Custom coordinates if provided
        if not isinstance(self.y_label_coords, type(None)):
            self.ax.yaxis.set_label_coords(x=self.y_label_coords[0], y=self.y_label_coords[1])</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.attributes.method_background_color"><code class="name flex">
<span>def <span class="ident">method_background_color</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_background_color(self):
    self.fig.patch.set_facecolor(self.background_color_figure)
    self.ax.set_facecolor(self.background_color_plot)
    self.ax.patch.set_alpha(self.background_alpha)</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.attributes.method_cb"><code class="name flex">
<span>def <span class="ident">method_cb</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_cb(self):
    if self.color_bar is True:
        if isinstance(self.norm, type(None)):
            return print_color(&#34;No norm selected for colorbar. Set norm=&lt;parameter of choice&gt;&#34;, &#34;grey&#34;)

        # Obtain and apply limits
        if isinstance(self.cb_vmin, type(None)):
            self.cb_vmin = self.norm.min()
        if isinstance(self.cb_vmax, type(None)):
            self.cb_vmax = self.norm.max()
        self.graph.set_clim([self.cb_vmin, self.cb_vmax])

        # Normalization
        locator = np.linspace(self.cb_vmin, self.cb_vmax, self.cb_tick_number)

        # Colorbar
        cb_decimals = self.tick_ndecimals if isinstance(self.cb_tick_ndecimals, type(None)) \
            else self.cb_tick_ndecimals
        cbar = self.fig.colorbar(self.graph,
                                 ax=self.ax,
                                 # Add option to have different colormap and colorbar ranges
                                 norm=mpl.colors.Normalize(vmin=self.cb_vmin, vmax=self.cb_vmax),
                                 # Add option to have different colormap and colorbar ranges
                                 orientation=self.cb_orientation, shrink=self.shrink,
                                 ticks=locator,
                                 boundaries=locator if self.cb_hard_bounds is True else None,
                                 spacing=&#39;proportional&#39;,
                                 extend=self.extend,
                                 format=&#39;%.&#39; + str(cb_decimals) + &#39;f&#39;,
                                 pad=self.cb_pad,
                                 )

        # Ticks
        #   Locator
        cbar.locator = locator
        #   Direction
        cbar.ax.tick_params(axis=&#39;y&#39;, direction=&#39;out&#39;)
        #   Tick label pad and size
        cbar.ax.yaxis.set_tick_params(pad=self.cb_axis_labelpad, labelsize=self.cb_ticklabelsize)

        # Colorbar title
        if self.cb_orientation == &#39;vertical&#39;:
            if not isinstance(self.cb_title,
                              type(None)) and self.cb_y_title is False and self.cb_top_title is False:
                print(&#39;Input colorbar title location with booleans: cb_y_title=True or cb_top_title=True&#39;)
            if self.cb_y_title is True:
                cbar.ax.set_ylabel(self.cb_title, rotation=self.cb_title_rotation,
                                   labelpad=self.cb_ytitle_labelpad)
                text = cbar.ax.yaxis.label
                font = mpl.font_manager.FontProperties(family=self.font, style=self.cb_title_style,
                                                       size=self.cb_title_size + self.font_size_increase,
                                                       weight=self.cb_title_weight)
                text.set_font_properties(font)
            if self.cb_top_title is True:
                cbar.ax.set_title(self.cb_title, rotation=self.cb_title_rotation,
                                  fontdict={&#39;verticalalignment&#39;: &#39;baseline&#39;,
                                            &#39;horizontalalignment&#39;: &#39;left&#39;},
                                  pad=self.cb_top_title_pad)
                cbar.ax.title.set_position((self.x_cb_top_title, self.cb_top_title_y))
                text = cbar.ax.title
                font = mpl.font_manager.FontProperties(family=self.font, style=self.cb_title_style,
                                                       weight=self.cb_title_weight,
                                                       size=self.cb_title + self.font_size_increase)
                text.set_font_properties(font)
        elif self.cb_orientation == &#39;horizontal&#39;:
            cbar.ax.set_xlabel(self.cb_title, rotation=self.cb_title_rotation, labelpad=self.cb_ytitle_labelpad)
            text = cbar.ax.xaxis.label
            font = mpl.font_manager.FontProperties(family=self.font, style=self.cb_title_style,
                                                   size=self.cb_title_size + self.font_size_increase,
                                                   weight=self.cb_title_weight)
            text.set_font_properties(font)

        # Outline
        cbar.outline.set_edgecolor(self.workspace_color2)
        cbar.outline.set_linewidth(self.cb_outline_width)</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.attributes.method_legend"><code class="name flex">
<span>def <span class="ident">method_legend</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_legend(self):
    if self.legend is True:
        lines_labels = [ax.get_legend_handles_labels() for ax in self.fig.axes]
        lines, labels = [sum(lol, []) for lol in zip(*lines_labels)]
        legend_font = font_manager.FontProperties(family=self.font,
                                                  weight=self.legend_weight,
                                                  style=self.legend_style,
                                                  size=self.legend_size + self.font_size_increase)
        self.legend = self.fig.legend(lines, labels,
                                      loc=self.legend_loc,
                                      bbox_to_anchor=self.legend_bbox_to_anchor, prop=legend_font,
                                      handleheight=self.legend_handleheight, ncol=self.legend_ncol)</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.attributes.method_resize_axes"><code class="name flex">
<span>def <span class="ident">method_resize_axes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_resize_axes(self):

    # Bound definition
    if not isinstance(self.x_bounds, type(None)):
        if not isinstance(self.x_bounds[0], type(None)):
            self.x_lower_bound = self.x_bounds[0]
        if not isinstance(self.x_bounds[1], type(None)):
            self.x_upper_bound = self.x_bounds[1]
    if not isinstance(self.y_bounds, type(None)):
        if not isinstance(self.y_bounds[0], type(None)):
            self.y_lower_bound = self.y_bounds[0]
        if not isinstance(self.y_bounds[1], type(None)):
            self.y_upper_bound = self.y_bounds[1]

    if self.resize_axes is True:

        def bounds(d, u, l, up, lp, v):
            # Upper and lower bounds
            if isinstance(u, type(None)):
                u = d.max()
            else:
                up = 0
            if isinstance(l, type(None)):
                l = d.min()
            else:
                lp = 0
            # Bounds vector
            if isinstance(v, type(None)):
                v = [self.x_lower_bound, self.x_upper_bound]
            if isinstance(v[0], type(None)):
                v[0] = l
            if isinstance(v[1], type(None)):
                v[1] = u
            return v, up, lp

        self.x_bounds, self.x_upper_resize_pad, self.x_lower_resize_pad = bounds(self.x,
                                                                                 self.x_upper_bound,
                                                                                 self.x_lower_bound,
                                                                                 self.x_upper_resize_pad,
                                                                                 self.x_lower_resize_pad,
                                                                                 self.x_bounds)
        self.y_bounds, self.y_upper_resize_pad, self.y_lower_resize_pad = bounds(self.y,
                                                                                 self.y_upper_bound,
                                                                                 self.y_lower_bound,
                                                                                 self.y_upper_resize_pad,
                                                                                 self.y_lower_resize_pad,
                                                                                 self.y_bounds)

        # Room to breathe
        if self.demo_pad_plot is True:
            pad_x = 0.05 * (abs(self.x + self.x.min()).max() - abs(self.x + self.x.min()).min())
            self.x_upper_resize_pad = pad_x
            self.x_lower_resize_pad = pad_x
            pad_y = 0.05 * (abs(self.y + self.y.min()).max() - abs(self.y + self.y.min()).min())
            self.y_upper_resize_pad = pad_y
            self.y_lower_resize_pad = pad_y

        # Allow constant input and single coordinate plots
        # Single coordinate plots
        if span(self.x_bounds) == 0 and span(self.y_bounds) == 0:
            # x bounds
            self.x_bounds = [self.x - self.x/2, self.x + self.x/2]
            self.x_upper_resize_pad = 0
            self.x_lower_resize_pad = 0
            # y bounds
            self.y_bounds = [self.y - self.y/2, self.y + self.y/2]
            self.y_upper_resize_pad = 0
            self.y_lower_resize_pad = 0
        # Constant x coordinate plot
        elif span(self.x_bounds) == 0:
            self.x_bounds = [self.x[0] - span(self.y)/2, self.x[0] + span(self.y)/2]
            self.x_upper_resize_pad = self.y_upper_resize_pad
            self.x_lower_resize_pad = self.y_lower_resize_pad
        # Constant y coordinate plot
        elif span(self.y_bounds) == 0:
            self.y_bounds = [self.y[0] - span(self.x)/2, self.y[0] + span(self.x)/2]
            self.y_upper_resize_pad = self.x_upper_resize_pad
            self.y_lower_resize_pad = self.x_lower_resize_pad

        # Set bounds
        self.ax.set_xbound(lower=self.x_bounds[0] - self.x_lower_resize_pad,
                           upper=self.x_bounds[1] + self.x_upper_resize_pad)
        self.ax.set_ybound(lower=self.y_bounds[0] - self.y_lower_resize_pad,
                           upper=self.y_bounds[1] + self.y_upper_resize_pad)

        self.ax.set_xlim(self.x_bounds[0] - self.x_lower_resize_pad,
                         self.x_bounds[1] + self.x_upper_resize_pad)
        self.ax.set_ylim(self.y_bounds[0] - self.y_lower_resize_pad,
                         self.y_bounds[1] + self.y_upper_resize_pad)

        # Aspect ratio
        if not isinstance(self.aspect, type(None)) and span(self.x_bounds) != 0 and span(self.y_bounds) != 0:
            y_range = span(self.y_bounds)
            x_range = span(self.x_bounds)

            aspect = x_range/y_range * self.aspect

            self.ax.set_aspect(aspect)

        # Scale
        if not isinstance(self.scale, type(None)):
            self.ax.set_aspect(self.scale)</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.attributes.method_spines"><code class="name flex">
<span>def <span class="ident">method_spines</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_spines(self):
    for spine in self.ax.spines.values():
        spine.set_color(self.workspace_color if isinstance(self.spine_color, type(None)) else self.spine_color)

    if not isinstance(self.spines_removed, type(None)):
        for i in range(len(self.spines_removed)):
            if self.spines_removed[i] == 1:
                self.ax.spines[[&#34;left&#34;, &#34;bottom&#34;, &#34;top&#34;, &#34;right&#34;][i]].set_visible(False)

    # Axis ticks
    left, bottom, top, right = self.ticks_where
    # Tick labels
    labelleft, labelbottom, labeltop, labelright = self.tick_labels_where

    self.ax.tick_params(axis=&#39;both&#39;, which=&#39;both&#39;,
                        top=top, right=right, left=left, bottom=bottom,
                        labeltop=labeltop, labelright=labelright, labelleft=labelleft, labelbottom=labelbottom)</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.attributes.method_ticks"><code class="name flex">
<span>def <span class="ident">method_ticks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Defaults</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_ticks(self):
    &#34;&#34;&#34;
    Defaults
    &#34;&#34;&#34;
    # Fine tick locations
    if not isinstance(self.y, type(None)):  # Avoid issues with arrays with span 0 (vertical or horizontal lines)
        if span(self.y) == 0:
            self.fine_tick_locations = False
    if self.fine_tick_locations is True:
        if not isinstance(self.x, type(None)) and isinstance(self.x_custom_tick_locations, type(None)):
            self.x_custom_tick_locations = [self.x.min(), self.x.max()]
        if not isinstance(self.y, type(None)) and isinstance(self.y_custom_tick_locations, type(None)):
            self.y_custom_tick_locations = [self.y.min(), self.y.max()]
    &#34;&#34;&#34;
    Checks
    &#34;&#34;&#34;
    # Custom tick labels
    if not isinstance(self.x_custom_tick_labels, type(None)):           # Ensure the number of ticks equals the
        if self.x_tick_number != len(self.x_custom_tick_labels):        # length of the list of custom tick
            self.x_tick_number = len(self.x_custom_tick_labels)         # labels.
    &#34;&#34;&#34;
    Implementation
    &#34;&#34;&#34;
    #   Tick-label distance
    self.ax.xaxis.set_tick_params(pad=0.1, direction=&#39;in&#39;)
    self.ax.yaxis.set_tick_params(pad=0.1, direction=&#39;in&#39;)
    #   Color
    if not isinstance(self.tick_color, type(None)):
        self.ax.tick_params(axis=&#39;both&#39;, color=self.tick_color)
    #   Label font and color
    for tick in self.ax.get_xticklabels():
        tick.set_fontname(self.font)
        tick.set_color(self.workspace_color if self.font_color == self.workspace_color else self.font_color)
    for tick in self.ax.get_yticklabels():
        tick.set_fontname(self.font)
        tick.set_color(self.workspace_color if self.font_color == self.workspace_color else self.font_color)
    #   Label size
    if not isinstance(self.x_tick_label_size, type(None)):
        self.ax.tick_params(axis=&#39;x&#39;, labelsize=self.x_tick_label_size + self.font_size_increase)
    elif not isinstance(self.tick_label_size, type(None)):
        self.ax.tick_params(axis=&#39;x&#39;, labelsize=self.tick_label_size + self.font_size_increase)
    if not isinstance(self.y_tick_label_size, type(None)):
        self.ax.tick_params(axis=&#39;y&#39;, labelsize=self.y_tick_label_size + self.font_size_increase)
    elif not isinstance(self.tick_label_size, type(None)):
        self.ax.tick_params(axis=&#39;y&#39;, labelsize=self.tick_label_size + self.font_size_increase)
    #   Custom tick positions
    if not isinstance(self.x_custom_tick_locations, type(None)):
        high = self.x_custom_tick_locations[0]
        low = self.x_custom_tick_locations[1]
        # Set usual ticks
        if self.x_tick_number &gt; 1:
            ticklocs = np.linspace(low, high, self.x_tick_number)
        # Special case: single tick
        else:
            ticklocs = np.array([low + (high - low)/2])
        self.ax.set_xticks(ticklocs)
    if not isinstance(self.y_custom_tick_locations, type(None)):
        high = self.y_custom_tick_locations[0]
        low = self.y_custom_tick_locations[1]
        # Set usual ticks
        if self.y_tick_number &gt; 1:
            ticklocs = np.linspace(low, high, self.y_tick_number)
        # Special case: single tick
        else:
            ticklocs = np.array([low + (high - low)/2])
        self.ax.set_yticks(ticklocs)
    #   Prune
    if not isinstance(self.prune, type(None)):
        self.ax.xaxis.set_major_locator(self.plt.MaxNLocator(prune=self.prune))
    if not isinstance(self.prune, type(None)):
        self.ax.yaxis.set_major_locator(self.plt.MaxNLocator(prune=self.prune))
    #   Float format
    x_decimals = self.tick_ndecimals if isinstance(self.x_tick_ndecimals, type(None)) \
        else self.x_tick_ndecimals
    y_decimals = self.tick_ndecimals if isinstance(self.y_tick_ndecimals, type(None)) \
        else self.y_tick_ndecimals
    float_format_x = &#39;%.&#39; + str(x_decimals) + &#39;f&#39;
    float_format_y = &#39;%.&#39; + str(y_decimals) + &#39;f&#39;
    self.ax.xaxis.set_major_formatter(FormatStrFormatter(float_format_x))
    self.ax.yaxis.set_major_formatter(FormatStrFormatter(float_format_y))
    #   Custom tick labels
    if not isinstance(self.x_custom_tick_labels, type(None)):
        if len(self.x_custom_tick_labels) == 2 and len(self.x_custom_tick_labels) != self.x_tick_number:
            self.x_custom_tick_labels = np.linspace(self.x_custom_tick_labels[0],
                                                    self.x_custom_tick_labels[1],
                                                    self.x_tick_number)
        self.ax.set_xticklabels(self.x_custom_tick_labels[::-1])
    if not isinstance(self.y_custom_tick_labels, type(None)):
        if len(self.y_custom_tick_labels) == 2 and len(self.y_custom_tick_labels) != self.y_tick_number:
            self.y_custom_tick_labels = np.linspace(self.y_custom_tick_labels[0],
                                                    self.y_custom_tick_labels[1],
                                                    self.y_tick_number)
        self.ax.set_yticklabels(self.y_custom_tick_labels[::-1])
    #       Date tick labels
    if self.x_date_tick_labels is True:
        fmtd = pd.date_range(start=self.x[0], end=self.x[-1], periods=self.x_tick_number)
        fmtd = [dt.datetime.strftime(d, self.date_format) for d in fmtd]
        self.ax.set_xticklabels(fmtd)
    #   Tick-label pad ---------------------------------------------------------------------------------------------
    if not isinstance(self.tick_label_pad, type(None)):
        self.ax.tick_params(axis=&#39;both&#39;, pad=self.tick_label_pad)
    #   Rotation
    if not isinstance(self.x_tick_rotation, type(None)):
        self.ax.tick_params(axis=&#39;x&#39;, rotation=self.x_tick_rotation)
        for tick in self.ax.xaxis.get_majorticklabels():
            tick.set_horizontalalignment(&#34;right&#34;)
    if not isinstance(self.y_tick_rotation, type(None)):
        self.ax.tick_params(axis=&#39;y&#39;, rotation=self.y_tick_rotation)
        for tick in self.ax.yaxis.get_majorticklabels():
            tick.set_horizontalalignment(&#34;left&#34;)</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.attributes.method_title"><code class="name flex">
<span>def <span class="ident">method_title</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_title(self):
    if not isinstance(self.title, type(None)):
        self.ax.set_title(self.title,
                          fontname=self.font if isinstance(self.title_font, type(None)) else self.title_font,
                          weight=self.title_weight,
                          color=self.title_color if not isinstance(self.title_color, type(None))
                                else self.font_color if not isinstance(self.font_color, type(None))
                                else self.workspace_color,
                          size=self.title_size + self.font_size_increase)
        self.ax.title.set_position((0.5, self.title_y))</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.attributes.method_workspace_style"><code class="name flex">
<span>def <span class="ident">method_workspace_style</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_workspace_style(self):
    if self.light:
        self.workspace_color = &#39;black&#39; if isinstance(self.workspace_color, type(None)) else self.workspace_color
        self.workspace_color2 = (193/256, 193/256, 193/256) if isinstance(self.workspace_color2, type(
            None)) else self.workspace_color2
        self.style = &#39;classic&#39;
    elif self.dark:
        self.workspace_color = &#39;white&#39; if isinstance(self.workspace_color, type(None)) else self.workspace_color
        self.workspace_color2 = (89/256, 89/256, 89/256) if isinstance(self.workspace_color2,
                                                                             type(
                                                                                 None)) else self.workspace_color2
        self.style = &#39;dark_background&#39;
    else:
        self.workspace_color = &#39;black&#39; if isinstance(self.workspace_color, type(None)) else self.workspace_color
        self.workspace_color2 = (193/256, 193/256, 193/256) if isinstance(self.workspace_color2, type(
            None)) else self.workspace_color2</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mpl_plotter.two_d.canvas"><code class="flex name class">
<span>class <span class="ident">canvas</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class canvas:

    def method_backend(self):
        if not isinstance(self.backend, type(None)):
            try:
                mpl.use(self.backend)
            except AttributeError:
                raise AttributeError(&#39;{} backend not supported with current Python configuration&#39;.format(self.backend))

        # matplotlib.use() must be called *before* pylab, matplotlib.pyplot,
        # or matplotlib.backends is imported for the first time.

    def method_fonts(self):
        &#34;&#34;&#34;
        Fonts
        Reference:
            - https://matplotlib.org/2.0.2/users/customizing.html
        Pyplot method:
            plt.rcParams[&#39;&lt;category&gt;.&lt;item&gt;&#39;] = &lt;&gt;
        &#34;&#34;&#34;
        mpl.rc(&#39;font&#39;, family=self.font)
        mpl.rc(&#39;font&#39;, serif=&#34;DejaVu Serif&#34; if self.font == &#34;serif&#34; else self.font)
        self.plt.rcParams[&#39;font.sans-serif&#39;] = &#34;DejaVu Serif&#34; if self.font == &#34;serif&#34; else self.font
        mpl.rc(&#39;font&#39;, cursive=&#34;Apple Chancery&#34; if self.font == &#34;serif&#34; else self.font)
        mpl.rc(&#39;font&#39;, fantasy=&#34;Chicago&#34; if self.font == &#34;serif&#34; else self.font)
        mpl.rc(&#39;font&#39;, monospace=&#34;Bitstream Vera Sans Mono&#34; if self.font == &#34;serif&#34; else self.font)

        mpl.rc(&#39;mathtext&#39;, fontset=self.math_font)
        mpl.rc(&#39;text&#39;, color=self.font_color)

    def method_setup(self):
        if isinstance(self.fig, type(None)):
            if not self.plt.get_fignums():
                self.method_figure()
            else:
                self.fig = self.plt.gcf()
                self.ax = self.plt.gca()

        if isinstance(self.ax, type(None)):
            self.ax = self.fig.add_subplot(self.shape_and_position, adjustable=&#39;box&#39;)

    def method_figure(self):
        if not isinstance(self.style, type(None)):
            self.plt.style.use(self.style)
        self.fig = self.plt.figure(figsize=self.figsize)

    def method_grid(self):
        if self.grid:
            self.ax.grid(linestyle=self.grid_lines, color=self.grid_color)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpl_plotter.setup.custom_canvas2" href="setup.html#mpl_plotter.setup.custom_canvas2">custom_canvas2</a></li>
<li><a title="mpl_plotter.two_d.plot" href="#mpl_plotter.two_d.plot">plot</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mpl_plotter.two_d.canvas.method_backend"><code class="name flex">
<span>def <span class="ident">method_backend</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_backend(self):
    if not isinstance(self.backend, type(None)):
        try:
            mpl.use(self.backend)
        except AttributeError:
            raise AttributeError(&#39;{} backend not supported with current Python configuration&#39;.format(self.backend))</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.canvas.method_figure"><code class="name flex">
<span>def <span class="ident">method_figure</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_figure(self):
    if not isinstance(self.style, type(None)):
        self.plt.style.use(self.style)
    self.fig = self.plt.figure(figsize=self.figsize)</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.canvas.method_fonts"><code class="name flex">
<span>def <span class="ident">method_fonts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonts</p>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://matplotlib.org/2.0.2/users/customizing.html">https://matplotlib.org/2.0.2/users/customizing.html</a>
Pyplot method:
plt.rcParams['<category>.<item>'] = &lt;&gt;</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_fonts(self):
    &#34;&#34;&#34;
    Fonts
    Reference:
        - https://matplotlib.org/2.0.2/users/customizing.html
    Pyplot method:
        plt.rcParams[&#39;&lt;category&gt;.&lt;item&gt;&#39;] = &lt;&gt;
    &#34;&#34;&#34;
    mpl.rc(&#39;font&#39;, family=self.font)
    mpl.rc(&#39;font&#39;, serif=&#34;DejaVu Serif&#34; if self.font == &#34;serif&#34; else self.font)
    self.plt.rcParams[&#39;font.sans-serif&#39;] = &#34;DejaVu Serif&#34; if self.font == &#34;serif&#34; else self.font
    mpl.rc(&#39;font&#39;, cursive=&#34;Apple Chancery&#34; if self.font == &#34;serif&#34; else self.font)
    mpl.rc(&#39;font&#39;, fantasy=&#34;Chicago&#34; if self.font == &#34;serif&#34; else self.font)
    mpl.rc(&#39;font&#39;, monospace=&#34;Bitstream Vera Sans Mono&#34; if self.font == &#34;serif&#34; else self.font)

    mpl.rc(&#39;mathtext&#39;, fontset=self.math_font)
    mpl.rc(&#39;text&#39;, color=self.font_color)</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.canvas.method_grid"><code class="name flex">
<span>def <span class="ident">method_grid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_grid(self):
    if self.grid:
        self.ax.grid(linestyle=self.grid_lines, color=self.grid_color)</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.canvas.method_setup"><code class="name flex">
<span>def <span class="ident">method_setup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_setup(self):
    if isinstance(self.fig, type(None)):
        if not self.plt.get_fignums():
            self.method_figure()
        else:
            self.fig = self.plt.gcf()
            self.ax = self.plt.gca()

    if isinstance(self.ax, type(None)):
        self.ax = self.fig.add_subplot(self.shape_and_position, adjustable=&#39;box&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mpl_plotter.two_d.df_input"><code class="flex name class">
<span>class <span class="ident">df_input</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class df_input:

    def method_resize_axes_dataframe(self):
        if self.resize_axes is True:
            xmin = 0
            ymin = 0
            xmax = self.z.shape[0]
            ymax = self.z.shape[1]
            if isinstance(self.x_upper_bound, type(None)):
                self.x_upper_bound = xmax
            if isinstance(self.x_lower_bound, type(None)):
                self.x_lower_bound = xmin
            if isinstance(self.y_upper_bound, type(None)):
                self.y_upper_bound = ymax
            if isinstance(self.y_lower_bound, type(None)):
                self.y_lower_bound = ymin

            if not isinstance(self.scale, type(None)):
                self.ax.set_aspect(self.scale)

            if not isinstance(self.aspect, type(None)):
                y_range = abs(ymax) + abs(ymin)
                x_range = abs(xmax) + abs(xmin)

                aspect = x_range/y_range * self.aspect

                self.ax.set_aspect(aspect)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpl_plotter.two_d.heatmap" href="#mpl_plotter.two_d.heatmap">heatmap</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mpl_plotter.two_d.df_input.method_resize_axes_dataframe"><code class="name flex">
<span>def <span class="ident">method_resize_axes_dataframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_resize_axes_dataframe(self):
    if self.resize_axes is True:
        xmin = 0
        ymin = 0
        xmax = self.z.shape[0]
        ymax = self.z.shape[1]
        if isinstance(self.x_upper_bound, type(None)):
            self.x_upper_bound = xmax
        if isinstance(self.x_lower_bound, type(None)):
            self.x_lower_bound = xmin
        if isinstance(self.y_upper_bound, type(None)):
            self.y_upper_bound = ymax
        if isinstance(self.y_lower_bound, type(None)):
            self.y_lower_bound = ymin

        if not isinstance(self.scale, type(None)):
            self.ax.set_aspect(self.scale)

        if not isinstance(self.aspect, type(None)):
            y_range = abs(ymax) + abs(ymin)
            x_range = abs(xmax) + abs(xmin)

            aspect = x_range/y_range * self.aspect

            self.ax.set_aspect(aspect)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mpl_plotter.two_d.fill_area"><code class="flex name class">
<span>class <span class="ident">fill_area</span></span>
<span>(</span><span>x=None, y=None, z=None, between=False, below=False, above=False, color=None, cmap='RdBu_r', alpha=None, norm=None, backend='Qt5Agg', font='serif', math_font='dejavuserif', font_color='black', font_size_increase=0, fig=None, ax=None, figsize=None, shape_and_position=111, prune=None, resize_axes=True, scale=None, aspect=1, workspace_color=None, workspace_color2=None, background_color_figure='white', background_color_plot='white', background_alpha=1, style=None, light=None, dark=None, spine_color=None, spines_removed=(0, 0, 1, 1), x_upper_bound=None, x_lower_bound=None, y_upper_bound=None, y_lower_bound=None, x_bounds=None, y_bounds=None, demo_pad_plot=False, x_upper_resize_pad=0, x_lower_resize_pad=0, y_upper_resize_pad=0, y_lower_resize_pad=0, grid=True, grid_color='lightgrey', grid_lines='-.', title=None, title_size=12, title_y=1.025, title_weight=None, title_font=None, title_color=None, x_label=None, x_label_size=12, x_label_pad=10, x_label_rotation=None, x_label_weight=None, y_label=None, y_label_size=12, y_label_pad=10, y_label_rotation=None, y_label_weight=None, x_tick_number=5, y_tick_number=5, x_label_coords=None, y_label_coords=None, tick_color=None, tick_label_pad=5, ticks_where=(1, 1, 0, 0), tick_label_size=10, x_tick_label_size=None, y_tick_label_size=None, x_custom_tick_locations=None, y_custom_tick_locations=None, fine_tick_locations=True, x_custom_tick_labels=None, y_custom_tick_labels=None, x_date_tick_labels=False, date_format='%Y-%m-%d', tick_ndecimals=1, x_tick_ndecimals=None, y_tick_ndecimals=None, x_tick_rotation=None, y_tick_rotation=None, tick_labels_where=(1, 1, 0, 0), color_bar=False, cb_pad=0.2, cb_axis_labelpad=10, shrink=0.75, extend='neither', cb_title=None, cb_orientation='vertical', cb_title_rotation=None, cb_title_style='normal', cb_title_size=10, cb_top_title_y=1, cb_ytitle_labelpad=10, cb_title_weight='normal', cb_top_title=False, cb_y_title=False, cb_top_title_pad=None, x_cb_top_title=0, cb_vmin=None, cb_vmax=None, cb_hard_bounds=False, cb_outline_width=None, cb_tick_number=5, cb_ticklabelsize=10, cb_tick_ndecimals=None, plot_label=None, legend=False, legend_loc='upper right', legend_bbox_to_anchor=None, legend_size=13, legend_weight='normal', legend_style='normal', legend_handleheight=None, legend_ncol=1, show=False, zorder=None, filename=None, dpi=None, suppress=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill area class
mpl_plotter - 2D</p>
<p>Specifics
:param x: Horizontal axis values
:param y: Curve 1
:param z: Curve 2</p>
<p>The following parameters can be used in combination:</p>
<p>:param between: Fill between Curve 1 and Curve 2
:param below: Fill below Curve 1 and Curve 2
:param above: Fill above Curve 1 and Curve 2</p>
<p>Color:
:param color: Solid color
:param cmap: Colormap
:param alpha: Alpha
:param norm: Norm to assign colormap values</p>
<p>Other
:param backend: Interactive plotting backends. Working with Python 3.7.6: Qt5Agg, QT4Agg, TkAgg.
Backend error:
pip install pyqt5
pip install tkinter
pip install tk
&hellip; stackoverflow
Plotting window freezes even if trying different backends with no backend error: python configuration problem
backend=None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class fill_area(plot, std_input):

    def __init__(self,
                 # Specifics
                 x=None, y=None, z=None, between=False, below=False, above=False,
                 # Specifics: color
                 color=None, cmap=&#39;RdBu_r&#39;, alpha=None, norm=None,
                 # Backend
                 backend=&#39;Qt5Agg&#39;,
                 # Fonts
                 font=&#39;serif&#39;, math_font=&#34;dejavuserif&#34;, font_color=&#34;black&#34;, font_size_increase=0,
                 # Figure, axes
                 fig=None, ax=None, figsize=None, shape_and_position=111, prune=None, resize_axes=True,
                 scale=None, aspect=1,
                 # Setup
                 workspace_color=None, workspace_color2=None,
                 background_color_figure=&#39;white&#39;, background_color_plot=&#39;white&#39;, background_alpha=1,
                 style=None, light=None, dark=None,
                 # Spines
                 spine_color=None, spines_removed=(0, 0, 1, 1),
                 # Bounds
                 x_upper_bound=None, x_lower_bound=None,
                 y_upper_bound=None, y_lower_bound=None,
                 x_bounds=None, y_bounds=None,
                 # Pads
                 demo_pad_plot=False,
                 x_upper_resize_pad=0, x_lower_resize_pad=0,
                 y_upper_resize_pad=0, y_lower_resize_pad=0,
                 # Grid
                 grid=True, grid_color=&#39;lightgrey&#39;, grid_lines=&#39;-.&#39;,
                 # Title
                 title=None, title_size=12, title_y=1.025, title_weight=None, title_font=None, title_color=None,
                 # Labels
                 x_label=None, x_label_size=12, x_label_pad=10, x_label_rotation=None, x_label_weight=None,
                 y_label=None, y_label_size=12, y_label_pad=10, y_label_rotation=None, y_label_weight=None,
                 # Ticks
                 x_tick_number=5,
                 y_tick_number=5,
                 x_label_coords=None, y_label_coords=None,
                 tick_color=None, tick_label_pad=5,
                 ticks_where=(1, 1, 0, 0),
                 # Tick labels
                 tick_label_size=10, x_tick_label_size=None, y_tick_label_size=None,
                 x_custom_tick_locations=None, y_custom_tick_locations=None, fine_tick_locations=True,
                 x_custom_tick_labels=None, y_custom_tick_labels=None,
                 x_date_tick_labels=False, date_format=&#39;%Y-%m-%d&#39;,
                 tick_ndecimals=1, x_tick_ndecimals=None, y_tick_ndecimals=None,
                 x_tick_rotation=None, y_tick_rotation=None,
                 tick_labels_where=(1, 1, 0, 0),
                 # Color bar
                 color_bar=False, cb_pad=0.2, cb_axis_labelpad=10, shrink=0.75, extend=&#39;neither&#39;,
                 cb_title=None, cb_orientation=&#39;vertical&#39;,
                 cb_title_rotation=None, cb_title_style=&#39;normal&#39;, cb_title_size=10,
                 cb_top_title_y=1, cb_ytitle_labelpad=10, cb_title_weight=&#39;normal&#39;, cb_top_title=False,
                 cb_y_title=False, cb_top_title_pad=None, x_cb_top_title=0,
                 cb_vmin=None, cb_vmax=None, cb_hard_bounds=False, cb_outline_width=None,
                 cb_tick_number=5, cb_ticklabelsize=10, cb_tick_ndecimals=None,
                 # Legend
                 plot_label=None,
                 legend=False, legend_loc=&#39;upper right&#39;, legend_bbox_to_anchor=None,
                 legend_size=13, legend_weight=&#39;normal&#39;,
                 legend_style=&#39;normal&#39;, legend_handleheight=None, legend_ncol=1,
                 # Subplots
                 show=False, zorder=None,
                 # Save
                 filename=None, dpi=None,
                 # Suppress output
                 suppress=True
                 ):

        &#34;&#34;&#34;
        Fill area class
        mpl_plotter - 2D

        Specifics
        :param x: Horizontal axis values
        :param y: Curve 1
        :param z: Curve 2

        The following parameters can be used in combination:

        :param between: Fill between Curve 1 and Curve 2
        :param below: Fill below Curve 1 and Curve 2
        :param above: Fill above Curve 1 and Curve 2

        Color:
        :param color: Solid color
        :param cmap: Colormap
        :param alpha: Alpha
        :param norm: Norm to assign colormap values

        Other
        :param backend: Interactive plotting backends. Working with Python 3.7.6: Qt5Agg, QT4Agg, TkAgg.
                        Backend error:
                            pip install pyqt5
                            pip install tkinter
                            pip install tk
                            ... stackoverflow
                        Plotting window freezes even if trying different backends with no backend error: python configuration problem
                            backend=None
        &#34;&#34;&#34;

        # Turn all instance arguments to instance attributes
        for item in inspect.signature(fill_area).parameters:
            setattr(self, item, eval(item))

        self.init()

    def plot(self):

        &#34;&#34;&#34;
        Fill the region below the intersection of S and Z
        &#34;&#34;&#34;
        if not isinstance(self.z, type(None)):
            if self.between is True:
                self.ax.fill_between(self.x, self.y, self.z, facecolor=self.color,
                                     alpha=self.alpha, label=self.plot_label)
            if self.below is True:
                self.ax.fill_between(self.x, self.i_below(), np.zeros(self.y.shape), facecolor=self.color,
                                     alpha=self.alpha, label=self.plot_label)
            if self.above is True:
                self.ax.fill_between(self.x, self.i_above(), np.zeros(self.y.shape), facecolor=self.color,
                                     alpha=self.alpha, label=self.plot_label)
            if self.between is False and self.below is False and self.above is False:
                print_color(&#39;No area chosen to fill: specify whether to fill &#34;between&#34;, &#34;below&#34; or &#34;above&#34; the curves&#39;,
                            &#39;grey&#39;)
        else:
            self.ax.fill_between(self.x, self.y, np.zeros(self.y.shape), facecolor=self.color, alpha=self.alpha)

    def i_below(self):
        # Curve
        c = np.zeros(self.y.shape, dtype=float)
        for i in range(len(c)):
            c[i] = self.y[i] if self.y[i] &lt;= self.z[i] else self.z[i]
        return c

    def i_above(self):
        # Curve
        c = np.zeros(self.y.shape, dtype=float)
        for i in range(len(c)):
            c[i] = self.y[i] if self.y[i] &gt;= self.z[i] else self.z[i]
        return c

    def intersection(self):
        return np.nonzero(np.absolute(self.y - self.z) == min(np.absolute(self.y - self.z)))[0]

    def mock(self):
        if isinstance(self.x, type(None)) and isinstance(self.y, type(None)):
            self.x = np.arange(-6, 6, .01)
            self.y = MockData().boltzman(self.x, 0, 1)
            self.z = 1 - MockData().boltzman(self.x, 0.5, 1)
            line(fig=self.fig, ax=self.ax, x=self.x, y=self.y, color=&#39;darkred&#39;, line_width=2, grid=not self.grid,
                 plot_label=None, backend=self.backend)
            line(fig=self.fig, ax=self.ax, x=self.x, y=self.z, color=&#39;darkred&#39;, line_width=2, grid=not self.grid,
                 plot_label=None, backend=self.backend)
            self.below = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mpl_plotter.two_d.plot" href="#mpl_plotter.two_d.plot">plot</a></li>
<li><a title="mpl_plotter.two_d.canvas" href="#mpl_plotter.two_d.canvas">canvas</a></li>
<li><a title="mpl_plotter.two_d.attributes" href="#mpl_plotter.two_d.attributes">attributes</a></li>
<li><a title="mpl_plotter.two_d.std_input" href="#mpl_plotter.two_d.std_input">std_input</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpl_plotter.presets.custom.two_d.fill_area" href="presets/custom.html#mpl_plotter.presets.custom.two_d.fill_area">two_d.fill_area</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mpl_plotter.two_d.fill_area.i_above"><code class="name flex">
<span>def <span class="ident">i_above</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def i_above(self):
    # Curve
    c = np.zeros(self.y.shape, dtype=float)
    for i in range(len(c)):
        c[i] = self.y[i] if self.y[i] &gt;= self.z[i] else self.z[i]
    return c</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.fill_area.i_below"><code class="name flex">
<span>def <span class="ident">i_below</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def i_below(self):
    # Curve
    c = np.zeros(self.y.shape, dtype=float)
    for i in range(len(c)):
        c[i] = self.y[i] if self.y[i] &lt;= self.z[i] else self.z[i]
    return c</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.fill_area.intersection"><code class="name flex">
<span>def <span class="ident">intersection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersection(self):
    return np.nonzero(np.absolute(self.y - self.z) == min(np.absolute(self.y - self.z)))[0]</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.fill_area.mock"><code class="name flex">
<span>def <span class="ident">mock</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mock(self):
    if isinstance(self.x, type(None)) and isinstance(self.y, type(None)):
        self.x = np.arange(-6, 6, .01)
        self.y = MockData().boltzman(self.x, 0, 1)
        self.z = 1 - MockData().boltzman(self.x, 0.5, 1)
        line(fig=self.fig, ax=self.ax, x=self.x, y=self.y, color=&#39;darkred&#39;, line_width=2, grid=not self.grid,
             plot_label=None, backend=self.backend)
        line(fig=self.fig, ax=self.ax, x=self.x, y=self.z, color=&#39;darkred&#39;, line_width=2, grid=not self.grid,
             plot_label=None, backend=self.backend)
        self.below = True</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.fill_area.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill the region below the intersection of S and Z</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self):

    &#34;&#34;&#34;
    Fill the region below the intersection of S and Z
    &#34;&#34;&#34;
    if not isinstance(self.z, type(None)):
        if self.between is True:
            self.ax.fill_between(self.x, self.y, self.z, facecolor=self.color,
                                 alpha=self.alpha, label=self.plot_label)
        if self.below is True:
            self.ax.fill_between(self.x, self.i_below(), np.zeros(self.y.shape), facecolor=self.color,
                                 alpha=self.alpha, label=self.plot_label)
        if self.above is True:
            self.ax.fill_between(self.x, self.i_above(), np.zeros(self.y.shape), facecolor=self.color,
                                 alpha=self.alpha, label=self.plot_label)
        if self.between is False and self.below is False and self.above is False:
            print_color(&#39;No area chosen to fill: specify whether to fill &#34;between&#34;, &#34;below&#34; or &#34;above&#34; the curves&#39;,
                        &#39;grey&#39;)
    else:
        self.ax.fill_between(self.x, self.y, np.zeros(self.y.shape), facecolor=self.color, alpha=self.alpha)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mpl_plotter.two_d.plot" href="#mpl_plotter.two_d.plot">plot</a></b></code>:
<ul class="hlist">
<li><code><a title="mpl_plotter.two_d.plot.method_fonts" href="#mpl_plotter.two_d.canvas.method_fonts">method_fonts</a></code></li>
<li><code><a title="mpl_plotter.two_d.plot.method_ticks" href="#mpl_plotter.two_d.attributes.method_ticks">method_ticks</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mpl_plotter.two_d.heatmap"><code class="flex name class">
<span>class <span class="ident">heatmap</span></span>
<span>(</span><span>x=None, y=None, z=None, normvariant='SymLog', color=None, cmap='RdBu_r', alpha=None, norm=None, backend='Qt5Agg', font='serif', math_font='dejavuserif', font_color='black', font_size_increase=0, fig=None, ax=None, figsize=None, shape_and_position=111, prune=None, resize_axes=True, scale=None, aspect=1, workspace_color=None, workspace_color2=None, background_color_figure='white', background_color_plot='white', background_alpha=1, style=None, light=None, dark=None, spine_color=None, spines_removed=(0, 0, 1, 1), x_upper_bound=None, x_lower_bound=None, y_upper_bound=None, y_lower_bound=None, x_bounds=None, y_bounds=None, demo_pad_plot=False, x_upper_resize_pad=0, x_lower_resize_pad=0, y_upper_resize_pad=0, y_lower_resize_pad=0, grid=True, grid_color='lightgrey', grid_lines='-.', title=None, title_size=12, title_y=1.025, title_weight=None, title_font=None, title_color=None, x_label=None, x_label_size=12, x_label_pad=10, x_label_rotation=None, x_label_weight=None, y_label=None, y_label_size=12, y_label_pad=10, y_label_rotation=None, y_label_weight=None, x_tick_number=5, y_tick_number=5, x_label_coords=None, y_label_coords=None, tick_color=None, tick_label_pad=5, ticks_where=(1, 1, 0, 0), tick_label_size=10, x_tick_label_size=None, y_tick_label_size=None, x_custom_tick_locations=None, y_custom_tick_locations=None, fine_tick_locations=True, x_custom_tick_labels=None, y_custom_tick_labels=None, x_date_tick_labels=False, date_format='%Y-%m-%d', tick_ndecimals=1, x_tick_ndecimals=None, y_tick_ndecimals=None, x_tick_rotation=None, y_tick_rotation=None, tick_labels_where=(1, 1, 0, 0), color_bar=False, cb_pad=0.2, cb_axis_labelpad=10, shrink=0.75, extend='neither', cb_title=None, cb_orientation='vertical', cb_title_rotation=None, cb_title_style='normal', cb_title_size=10, cb_top_title_y=1, cb_ytitle_labelpad=10, cb_title_weight='normal', cb_top_title=False, cb_y_title=False, cb_top_title_pad=None, x_cb_top_title=0, cb_vmin=None, cb_vmax=None, cb_hard_bounds=False, cb_outline_width=None, cb_tick_number=5, cb_ticklabelsize=10, cb_tick_ndecimals=None, plot_label=None, legend=False, legend_loc='upper right', legend_bbox_to_anchor=None, legend_size=13, legend_weight='normal', legend_style='normal', legend_handleheight=None, legend_ncol=1, show=False, zorder=None, filename=None, dpi=None, suppress=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Heatmap plot class
mpl_plotter - 2D</p>
<p>Specifics
:param x: x
:param y: y
:param z: z
:param normvariant: Detailed information in the Matplotlib documentation</p>
<p>Color:
:param color: Solid color
:param cmap: Colormap
:param alpha: Alpha
:param norm: Norm to assign colormap values</p>
<p>Other
:param backend: Interactive plotting backends. Working with Python 3.7.6: Qt5Agg, QT4Agg, TkAgg.
Backend error:
pip install pyqt5
pip install tkinter
pip install tk
&hellip; stackoverflow
Plotting window freezes even if trying different backends with no backend error: python configuration problem
backend=None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class heatmap(plot, df_input):

    def __init__(self,
                 # Specifics
                 x=None, y=None, z=None, normvariant=&#39;SymLog&#39;,
                 # Specifics: color
                 color=None, cmap=&#39;RdBu_r&#39;, alpha=None, norm=None,
                 # Backend
                 backend=&#39;Qt5Agg&#39;,
                 # Fonts
                 font=&#39;serif&#39;, math_font=&#34;dejavuserif&#34;, font_color=&#34;black&#34;, font_size_increase=0,
                 # Figure, axes
                 fig=None, ax=None, figsize=None, shape_and_position=111, prune=None, resize_axes=True,
                 scale=None, aspect=1,
                 # Setup
                 workspace_color=None, workspace_color2=None,
                 background_color_figure=&#39;white&#39;, background_color_plot=&#39;white&#39;, background_alpha=1,
                 style=None, light=None, dark=None,
                 # Spines
                 spine_color=None, spines_removed=(0, 0, 1, 1),
                 # Bounds
                 x_upper_bound=None, x_lower_bound=None,
                 y_upper_bound=None, y_lower_bound=None,
                 x_bounds=None, y_bounds=None,
                 # Pads
                 demo_pad_plot=False,
                 x_upper_resize_pad=0, x_lower_resize_pad=0,
                 y_upper_resize_pad=0, y_lower_resize_pad=0,
                 # Grid
                 grid=True, grid_color=&#39;lightgrey&#39;, grid_lines=&#39;-.&#39;,
                 # Title
                 title=None, title_size=12, title_y=1.025, title_weight=None, title_font=None, title_color=None,
                 # Labels
                 x_label=None, x_label_size=12, x_label_pad=10, x_label_rotation=None, x_label_weight=None,
                 y_label=None, y_label_size=12, y_label_pad=10, y_label_rotation=None, y_label_weight=None,
                 # Ticks
                 x_tick_number=5,
                 y_tick_number=5,
                 x_label_coords=None, y_label_coords=None,
                 tick_color=None, tick_label_pad=5,
                 ticks_where=(1, 1, 0, 0),
                 # Tick labels
                 tick_label_size=10, x_tick_label_size=None, y_tick_label_size=None,
                 x_custom_tick_locations=None, y_custom_tick_locations=None, fine_tick_locations=True,
                 x_custom_tick_labels=None, y_custom_tick_labels=None,
                 x_date_tick_labels=False, date_format=&#39;%Y-%m-%d&#39;,
                 tick_ndecimals=1, x_tick_ndecimals=None, y_tick_ndecimals=None,
                 x_tick_rotation=None, y_tick_rotation=None,
                 tick_labels_where=(1, 1, 0, 0),
                 # Color bar
                 color_bar=False, cb_pad=0.2, cb_axis_labelpad=10, shrink=0.75, extend=&#39;neither&#39;,
                 cb_title=None, cb_orientation=&#39;vertical&#39;,
                 cb_title_rotation=None, cb_title_style=&#39;normal&#39;, cb_title_size=10,
                 cb_top_title_y=1, cb_ytitle_labelpad=10, cb_title_weight=&#39;normal&#39;, cb_top_title=False,
                 cb_y_title=False, cb_top_title_pad=None, x_cb_top_title=0,
                 cb_vmin=None, cb_vmax=None, cb_hard_bounds=False, cb_outline_width=None,
                 cb_tick_number=5, cb_ticklabelsize=10, cb_tick_ndecimals=None,
                 # Legend
                 plot_label=None,
                 legend=False, legend_loc=&#39;upper right&#39;, legend_bbox_to_anchor=None,
                 legend_size=13, legend_weight=&#39;normal&#39;,
                 legend_style=&#39;normal&#39;, legend_handleheight=None, legend_ncol=1,
                 # Subplots
                 show=False, zorder=None,
                 # Save
                 filename=None, dpi=None,
                 # Suppress output
                 suppress=True
                 ):
        &#34;&#34;&#34;
        Heatmap plot class
        mpl_plotter - 2D

        Specifics
        :param x: x
        :param y: y
        :param z: z
        :param normvariant: Detailed information in the Matplotlib documentation

        Color:
        :param color: Solid color
        :param cmap: Colormap
        :param alpha: Alpha
        :param norm: Norm to assign colormap values

        Other
        :param backend: Interactive plotting backends. Working with Python 3.7.6: Qt5Agg, QT4Agg, TkAgg.
                        Backend error:
                            pip install pyqt5
                            pip install tkinter
                            pip install tk
                            ... stackoverflow
                        Plotting window freezes even if trying different backends with no backend error: python configuration problem
                            backend=None
        &#34;&#34;&#34;
        # Turn all instance arguments to instance attributes
        for item in inspect.signature(heatmap).parameters:
            setattr(self, item, eval(item))

        self.init()

    def plot(self):

        if not isinstance(self.x, type(None)) and not isinstance(self.y, type(None)):
            self.graph = self.ax.pcolormesh(self.x, self.y, self.z, cmap=self.cmap,
                                            zorder=self.zorder,
                                            alpha=self.alpha,
                                            label=self.plot_label,
                                            )
            # Resize axes
            self.method_resize_axes()

        else:
            self.graph = self.ax.pcolormesh(self.z, cmap=self.cmap, norm=self.norm,
                                            zorder=self.zorder,
                                            alpha=self.alpha,
                                            label=self.plot_label, )
            # Resize axes
            self.method_resize_axes_dataframe()

    def mock(self):
        if isinstance(self.x, type(None)) and isinstance(self.y, type(None)):
            self.z = MockData().waterdropdf()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mpl_plotter.two_d.plot" href="#mpl_plotter.two_d.plot">plot</a></li>
<li><a title="mpl_plotter.two_d.canvas" href="#mpl_plotter.two_d.canvas">canvas</a></li>
<li><a title="mpl_plotter.two_d.attributes" href="#mpl_plotter.two_d.attributes">attributes</a></li>
<li><a title="mpl_plotter.two_d.df_input" href="#mpl_plotter.two_d.df_input">df_input</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpl_plotter.presets.custom.two_d.heatmap" href="presets/custom.html#mpl_plotter.presets.custom.two_d.heatmap">two_d.heatmap</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mpl_plotter.two_d.heatmap.mock"><code class="name flex">
<span>def <span class="ident">mock</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mock(self):
    if isinstance(self.x, type(None)) and isinstance(self.y, type(None)):
        self.z = MockData().waterdropdf()</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.heatmap.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self):

    if not isinstance(self.x, type(None)) and not isinstance(self.y, type(None)):
        self.graph = self.ax.pcolormesh(self.x, self.y, self.z, cmap=self.cmap,
                                        zorder=self.zorder,
                                        alpha=self.alpha,
                                        label=self.plot_label,
                                        )
        # Resize axes
        self.method_resize_axes()

    else:
        self.graph = self.ax.pcolormesh(self.z, cmap=self.cmap, norm=self.norm,
                                        zorder=self.zorder,
                                        alpha=self.alpha,
                                        label=self.plot_label, )
        # Resize axes
        self.method_resize_axes_dataframe()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mpl_plotter.two_d.plot" href="#mpl_plotter.two_d.plot">plot</a></b></code>:
<ul class="hlist">
<li><code><a title="mpl_plotter.two_d.plot.method_fonts" href="#mpl_plotter.two_d.canvas.method_fonts">method_fonts</a></code></li>
<li><code><a title="mpl_plotter.two_d.plot.method_ticks" href="#mpl_plotter.two_d.attributes.method_ticks">method_ticks</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mpl_plotter.two_d.line"><code class="flex name class">
<span>class <span class="ident">line</span></span>
<span>(</span><span>x=None, y=None, line_width=2, color='darkred', cmap='RdBu_r', alpha=None, norm=None, backend='Qt5Agg', font='serif', math_font='dejavuserif', font_color='black', font_size_increase=0, fig=None, ax=None, figsize=None, shape_and_position=111, prune=None, resize_axes=True, scale=None, aspect=1, workspace_color=None, workspace_color2=None, background_color_figure='white', background_color_plot='white', background_alpha=1, style=None, light=None, dark=None, spine_color=None, spines_removed=(0, 0, 1, 1), x_upper_bound=None, x_lower_bound=None, y_upper_bound=None, y_lower_bound=None, x_bounds=None, y_bounds=None, demo_pad_plot=False, x_upper_resize_pad=0, x_lower_resize_pad=0, y_upper_resize_pad=0, y_lower_resize_pad=0, grid=True, grid_color='lightgrey', grid_lines='-.', title=None, title_size=12, title_y=1.025, title_weight=None, title_font=None, title_color=None, x_label=None, x_label_size=12, x_label_pad=10, x_label_rotation=None, x_label_weight=None, y_label=None, y_label_size=12, y_label_pad=10, y_label_rotation=None, y_label_weight=None, x_tick_number=5, y_tick_number=5, x_label_coords=None, y_label_coords=None, tick_color=None, tick_label_pad=5, ticks_where=(1, 1, 0, 0), tick_label_size=10, x_tick_label_size=None, y_tick_label_size=None, x_custom_tick_locations=None, y_custom_tick_locations=None, fine_tick_locations=True, x_custom_tick_labels=None, y_custom_tick_labels=None, x_date_tick_labels=False, date_format='%Y-%m-%d', tick_ndecimals=1, x_tick_ndecimals=None, y_tick_ndecimals=None, x_tick_rotation=None, y_tick_rotation=None, tick_labels_where=(1, 1, 0, 0), color_bar=False, cb_pad=0.2, cb_axis_labelpad=10, shrink=0.75, extend='neither', cb_title=None, cb_orientation='vertical', cb_title_rotation=None, cb_title_style='normal', cb_title_size=10, cb_top_title_y=1, cb_ytitle_labelpad=10, cb_title_weight='normal', cb_top_title=False, cb_y_title=False, cb_top_title_pad=None, x_cb_top_title=0, cb_vmin=None, cb_vmax=None, cb_hard_bounds=False, cb_outline_width=None, cb_tick_number=5, cb_ticklabelsize=10, cb_tick_ndecimals=None, plot_label=None, legend=False, legend_loc='upper right', legend_bbox_to_anchor=None, legend_size=13, legend_weight='normal', legend_style='normal', legend_handleheight=None, legend_ncol=1, show=False, zorder=None, filename=None, dpi=None, suppress=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Line plot class
mpl_plotter - 2D</p>
<p>Specifics
:param x: x
:param y: y
:param line_width: Line width</p>
<p>Color:
:param color: Solid color
:param cmap: Colormap
:param alpha: Alpha
:param norm: Norm to assign colormap values</p>
<p>Other
:param backend: Interactive plotting backends. Working with Python 3.7.6: Qt5Agg, QT4Agg, TkAgg.
Backend error:
pip install pyqt5
pip install tkinter
pip install tk
&hellip; stackoverflow
Plotting window freezes even if trying different backends with no backend error: python configuration problem
backend=None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class line(plot, std_input):

    def __init__(self,
                 # Specifics
                 x=None, y=None, line_width=2,
                 # Specifics: color
                 color=&#39;darkred&#39;, cmap=&#39;RdBu_r&#39;, alpha=None, norm=None,
                 # Backend
                 backend=&#39;Qt5Agg&#39;,
                 # Fonts
                 font=&#39;serif&#39;, math_font=&#34;dejavuserif&#34;, font_color=&#34;black&#34;, font_size_increase=0,
                 # Figure, axes
                 fig=None, ax=None, figsize=None, shape_and_position=111, prune=None, resize_axes=True,
                 scale=None, aspect=1,
                 # Setup
                 workspace_color=None, workspace_color2=None,
                 background_color_figure=&#39;white&#39;, background_color_plot=&#39;white&#39;, background_alpha=1,
                 style=None, light=None, dark=None,
                 # Spines
                 spine_color=None, spines_removed=(0, 0, 1, 1),
                 # Bounds
                 x_upper_bound=None, x_lower_bound=None,
                 y_upper_bound=None, y_lower_bound=None,
                 x_bounds=None, y_bounds=None,
                 # Pads
                 demo_pad_plot=False,
                 x_upper_resize_pad=0, x_lower_resize_pad=0,
                 y_upper_resize_pad=0, y_lower_resize_pad=0,
                 # Grid
                 grid=True, grid_color=&#39;lightgrey&#39;, grid_lines=&#39;-.&#39;,
                 # Title
                 title=None, title_size=12, title_y=1.025, title_weight=None, title_font=None, title_color=None,
                 # Labels
                 x_label=None, x_label_size=12, x_label_pad=10, x_label_rotation=None, x_label_weight=None,
                 y_label=None, y_label_size=12, y_label_pad=10, y_label_rotation=None, y_label_weight=None,
                 # Ticks
                 x_tick_number=5,
                 y_tick_number=5,
                 x_label_coords=None, y_label_coords=None,
                 tick_color=None, tick_label_pad=5,
                 ticks_where=(1, 1, 0, 0),
                 # Tick labels
                 tick_label_size=10, x_tick_label_size=None, y_tick_label_size=None,
                 x_custom_tick_locations=None, y_custom_tick_locations=None, fine_tick_locations=True,
                 x_custom_tick_labels=None, y_custom_tick_labels=None,
                 x_date_tick_labels=False, date_format=&#39;%Y-%m-%d&#39;,
                 tick_ndecimals=1, x_tick_ndecimals=None, y_tick_ndecimals=None,
                 x_tick_rotation=None, y_tick_rotation=None,
                 tick_labels_where=(1, 1, 0, 0),
                 # Color bar
                 color_bar=False, cb_pad=0.2, cb_axis_labelpad=10, shrink=0.75, extend=&#39;neither&#39;,
                 cb_title=None, cb_orientation=&#39;vertical&#39;,
                 cb_title_rotation=None, cb_title_style=&#39;normal&#39;, cb_title_size=10,
                 cb_top_title_y=1, cb_ytitle_labelpad=10, cb_title_weight=&#39;normal&#39;, cb_top_title=False,
                 cb_y_title=False, cb_top_title_pad=None, x_cb_top_title=0,
                 cb_vmin=None, cb_vmax=None, cb_hard_bounds=False, cb_outline_width=None,
                 cb_tick_number=5, cb_ticklabelsize=10, cb_tick_ndecimals=None,
                 # Legend
                 plot_label=None,
                 legend=False, legend_loc=&#39;upper right&#39;, legend_bbox_to_anchor=None,
                 legend_size=13, legend_weight=&#39;normal&#39;,
                 legend_style=&#39;normal&#39;, legend_handleheight=None, legend_ncol=1,
                 # Subplots
                 show=False, zorder=None,
                 # Save
                 filename=None, dpi=None,
                 # Suppress output
                 suppress=True
                 ):
        &#34;&#34;&#34;
        Line plot class
        mpl_plotter - 2D

        Specifics
        :param x: x
        :param y: y
        :param line_width: Line width

        Color:
        :param color: Solid color
        :param cmap: Colormap
        :param alpha: Alpha
        :param norm: Norm to assign colormap values

        Other
        :param backend: Interactive plotting backends. Working with Python 3.7.6: Qt5Agg, QT4Agg, TkAgg.
                        Backend error:
                            pip install pyqt5
                            pip install tkinter
                            pip install tk
                            ... stackoverflow
                        Plotting window freezes even if trying different backends with no backend error: python configuration problem
                            backend=None
        &#34;&#34;&#34;

        # Turn all instance arguments to instance attributes
        for item in inspect.signature(line).parameters:
            setattr(self, item, eval(item))

        self.init()

    def plot(self):

        if isinstance(self.norm, type(None)):
            self.graph = self.ax.plot(self.x, self.y, label=self.plot_label, linewidth=self.line_width,
                                      color=self.color,
                                      zorder=self.zorder,
                                      alpha=self.alpha,
                                      )
        else:
            # Create a set of line segments so that we can color them individually
            # This creates the points as a N x 1 x 2 array so that we can stack points
            # together easily to get the segments. The segments array for line collection
            # needs to be (numlines) x (points per line) x 2 (for x and y)
            points = np.array([self.x, self.y]).T.reshape(-1, 1, 2)
            segments = np.concatenate([points[:-1], points[1:]], axis=1)

            # Create a continuous norm to map from data points to colors
            _norm = self.norm(self.x) if hasattr(self.norm, &#39;__call__&#39;) else self.norm
            norm = self.plt.Normalize(_norm.min(), _norm.max())
            lc = mpl.collections.LineCollection(segments, cmap=self.cmap, norm=norm)

            # Set the values used for colormapping
            lc.set_array(self.norm)
            lc.set_linewidth(self.line_width)
            self.graph = self.ax.add_collection(lc)

    def mock(self):
        if isinstance(self.x, type(None)) and isinstance(self.y, type(None)):
            self.x, self.y = MockData().spirograph()
            if self.norm is True:
                self.norm = self.y</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mpl_plotter.two_d.plot" href="#mpl_plotter.two_d.plot">plot</a></li>
<li><a title="mpl_plotter.two_d.canvas" href="#mpl_plotter.two_d.canvas">canvas</a></li>
<li><a title="mpl_plotter.two_d.attributes" href="#mpl_plotter.two_d.attributes">attributes</a></li>
<li><a title="mpl_plotter.two_d.std_input" href="#mpl_plotter.two_d.std_input">std_input</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpl_plotter.presets.custom.two_d.line" href="presets/custom.html#mpl_plotter.presets.custom.two_d.line">two_d.line</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mpl_plotter.two_d.line.mock"><code class="name flex">
<span>def <span class="ident">mock</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mock(self):
    if isinstance(self.x, type(None)) and isinstance(self.y, type(None)):
        self.x, self.y = MockData().spirograph()
        if self.norm is True:
            self.norm = self.y</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.line.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self):

    if isinstance(self.norm, type(None)):
        self.graph = self.ax.plot(self.x, self.y, label=self.plot_label, linewidth=self.line_width,
                                  color=self.color,
                                  zorder=self.zorder,
                                  alpha=self.alpha,
                                  )
    else:
        # Create a set of line segments so that we can color them individually
        # This creates the points as a N x 1 x 2 array so that we can stack points
        # together easily to get the segments. The segments array for line collection
        # needs to be (numlines) x (points per line) x 2 (for x and y)
        points = np.array([self.x, self.y]).T.reshape(-1, 1, 2)
        segments = np.concatenate([points[:-1], points[1:]], axis=1)

        # Create a continuous norm to map from data points to colors
        _norm = self.norm(self.x) if hasattr(self.norm, &#39;__call__&#39;) else self.norm
        norm = self.plt.Normalize(_norm.min(), _norm.max())
        lc = mpl.collections.LineCollection(segments, cmap=self.cmap, norm=norm)

        # Set the values used for colormapping
        lc.set_array(self.norm)
        lc.set_linewidth(self.line_width)
        self.graph = self.ax.add_collection(lc)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mpl_plotter.two_d.plot" href="#mpl_plotter.two_d.plot">plot</a></b></code>:
<ul class="hlist">
<li><code><a title="mpl_plotter.two_d.plot.method_fonts" href="#mpl_plotter.two_d.canvas.method_fonts">method_fonts</a></code></li>
<li><code><a title="mpl_plotter.two_d.plot.method_ticks" href="#mpl_plotter.two_d.attributes.method_ticks">method_ticks</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mpl_plotter.two_d.plot"><code class="flex name class">
<span>class <span class="ident">plot</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class plot(canvas, attributes):

    def init(self):

        self.method_backend()

        self.plt = import_module(&#34;matplotlib.pyplot&#34;)

        &#34;&#34;&#34;
        Run
        &#34;&#34;&#34;

        self.run()

    def run(self):
        self.main()
        try:
            self.custom()
        except AttributeError:
            pass
        self.finish()

    def main(self):
        # Canvas setup
        self.method_fonts()
        self.method_setup()
        self.method_grid()
        self.method_background_color()
        self.method_workspace_style()

        # Mock plot
        self.mock()

        # Plot
        self.plot()

        # Colorbar
        self.method_cb()

    def finish(self):
        # Makeup
        self.method_title()
        self.method_axis_labels()
        self.method_spines()
        self.method_ticks()

        # Save
        self.method_save()

        self.method_show()

    def method_save(self):
        if self.filename:
            self.plt.savefig(self.filename, dpi=self.dpi)

    def method_show(self):
        if self.show is True:
            self.fig.tight_layout()
            self.plt.show()
        else:
            if self.suppress is False:
                print(&#39;Ready for next subplot&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mpl_plotter.two_d.canvas" href="#mpl_plotter.two_d.canvas">canvas</a></li>
<li><a title="mpl_plotter.two_d.attributes" href="#mpl_plotter.two_d.attributes">attributes</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpl_plotter.two_d.fill_area" href="#mpl_plotter.two_d.fill_area">fill_area</a></li>
<li><a title="mpl_plotter.two_d.heatmap" href="#mpl_plotter.two_d.heatmap">heatmap</a></li>
<li><a title="mpl_plotter.two_d.line" href="#mpl_plotter.two_d.line">line</a></li>
<li><a title="mpl_plotter.two_d.quiver" href="#mpl_plotter.two_d.quiver">quiver</a></li>
<li><a title="mpl_plotter.two_d.scatter" href="#mpl_plotter.two_d.scatter">scatter</a></li>
<li><a title="mpl_plotter.two_d.streamline" href="#mpl_plotter.two_d.streamline">streamline</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mpl_plotter.two_d.plot.finish"><code class="name flex">
<span>def <span class="ident">finish</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish(self):
    # Makeup
    self.method_title()
    self.method_axis_labels()
    self.method_spines()
    self.method_ticks()

    # Save
    self.method_save()

    self.method_show()</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.plot.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init(self):

    self.method_backend()

    self.plt = import_module(&#34;matplotlib.pyplot&#34;)

    &#34;&#34;&#34;
    Run
    &#34;&#34;&#34;

    self.run()</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.plot.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(self):
    # Canvas setup
    self.method_fonts()
    self.method_setup()
    self.method_grid()
    self.method_background_color()
    self.method_workspace_style()

    # Mock plot
    self.mock()

    # Plot
    self.plot()

    # Colorbar
    self.method_cb()</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.plot.method_save"><code class="name flex">
<span>def <span class="ident">method_save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_save(self):
    if self.filename:
        self.plt.savefig(self.filename, dpi=self.dpi)</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.plot.method_show"><code class="name flex">
<span>def <span class="ident">method_show</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_show(self):
    if self.show is True:
        self.fig.tight_layout()
        self.plt.show()
    else:
        if self.suppress is False:
            print(&#39;Ready for next subplot&#39;)</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.plot.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    self.main()
    try:
        self.custom()
    except AttributeError:
        pass
    self.finish()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mpl_plotter.two_d.canvas" href="#mpl_plotter.two_d.canvas">canvas</a></b></code>:
<ul class="hlist">
<li><code><a title="mpl_plotter.two_d.canvas.method_fonts" href="#mpl_plotter.two_d.canvas.method_fonts">method_fonts</a></code></li>
</ul>
</li>
<li><code><b><a title="mpl_plotter.two_d.attributes" href="#mpl_plotter.two_d.attributes">attributes</a></b></code>:
<ul class="hlist">
<li><code><a title="mpl_plotter.two_d.attributes.method_ticks" href="#mpl_plotter.two_d.attributes.method_ticks">method_ticks</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mpl_plotter.two_d.quiver"><code class="flex name class">
<span>class <span class="ident">quiver</span></span>
<span>(</span><span>x=None, y=None, u=None, v=None, color=None, cmap='RdBu_r', alpha=None, norm=None, rule=None, custom_rule=None, vector_width=0.01, vector_min_shaft=2, vector_length_threshold=0.1, backend='Qt5Agg', font='serif', math_font='dejavuserif', font_color='black', font_size_increase=0, fig=None, ax=None, figsize=None, shape_and_position=111, prune=None, resize_axes=True, scale=None, aspect=1, workspace_color=None, workspace_color2=None, background_color_figure='white', background_color_plot='white', background_alpha=1, style=None, light=None, dark=None, spine_color=None, spines_removed=(0, 0, 1, 1), x_upper_bound=None, x_lower_bound=None, y_upper_bound=None, y_lower_bound=None, x_bounds=None, y_bounds=None, demo_pad_plot=False, x_upper_resize_pad=0, x_lower_resize_pad=0, y_upper_resize_pad=0, y_lower_resize_pad=0, grid=True, grid_color='lightgrey', grid_lines='-.', title=None, title_size=12, title_y=1.025, title_weight=None, title_font=None, title_color=None, x_label=None, x_label_size=12, x_label_pad=10, x_label_rotation=None, x_label_weight=None, y_label=None, y_label_size=12, y_label_pad=10, y_label_rotation=None, y_label_weight=None, x_tick_number=5, y_tick_number=5, x_label_coords=None, y_label_coords=None, tick_color=None, tick_label_pad=5, ticks_where=(1, 1, 0, 0), tick_label_size=10, x_tick_label_size=None, y_tick_label_size=None, x_custom_tick_locations=None, y_custom_tick_locations=None, fine_tick_locations=True, x_custom_tick_labels=None, y_custom_tick_labels=None, x_date_tick_labels=False, date_format='%Y-%m-%d', tick_ndecimals=1, x_tick_ndecimals=None, y_tick_ndecimals=None, x_tick_rotation=None, y_tick_rotation=None, tick_labels_where=(1, 1, 0, 0), color_bar=False, cb_pad=0.2, cb_axis_labelpad=10, shrink=0.75, extend='neither', cb_title=None, cb_orientation='vertical', cb_title_rotation=None, cb_title_style='normal', cb_title_size=10, cb_top_title_y=1, cb_ytitle_labelpad=10, cb_title_weight='normal', cb_top_title=False, cb_y_title=False, cb_top_title_pad=None, x_cb_top_title=0, cb_vmin=None, cb_vmax=None, cb_hard_bounds=False, cb_outline_width=None, cb_tick_number=5, cb_ticklabelsize=10, cb_tick_ndecimals=None, plot_label=None, legend=False, legend_loc='upper right', legend_bbox_to_anchor=None, legend_size=13, legend_weight='normal', legend_style='normal', legend_handleheight=None, legend_ncol=1, show=False, zorder=None, filename=None, dpi=None, suppress=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Quiver plot class
mpl_plotter - 2D</p>
<p>Specifics
:param x: x
:param y: y
:param u: u
:param v: v
:param rule:
lambda function of u and v
rule = lambda u, v: (u<strong>2+v</strong>2)
:param custom_rule: Array assigning a color to each (x, y, u, v) vector
:param vector_width: Vector width
:param vector_min_shaft: Minimum vector shaft
:param vector_length_threshold: Minimum vector length</p>
<p>Color:
:param color: Solid color
:param cmap: Colormap
:param alpha: Alpha
:param norm: Norm to assign colormap values</p>
<p>Other
:param backend: Interactive plotting backends. Working with Python 3.7.6: Qt5Agg, QT4Agg, TkAgg.
Backend error:
pip install pyqt5
pip install tkinter
pip install tk
&hellip; stackoverflow
Plotting window freezes even if trying different backends with no backend error: python configuration problem
backend=None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class quiver(plot, std_input):

    def __init__(self,
                 # Specifics
                 x=None, y=None, u=None, v=None,
                 # Specifics: color
                 color=None, cmap=&#39;RdBu_r&#39;, alpha=None, norm=None,
                 rule=None, custom_rule=None, vector_width=0.01, vector_min_shaft=2, vector_length_threshold=0.1,
                 # Backend
                 backend=&#39;Qt5Agg&#39;,
                 # Fonts
                 font=&#39;serif&#39;, math_font=&#34;dejavuserif&#34;, font_color=&#34;black&#34;, font_size_increase=0,
                 # Figure, axes
                 fig=None, ax=None, figsize=None, shape_and_position=111, prune=None, resize_axes=True,
                 scale=None, aspect=1,
                 # Setup
                 workspace_color=None, workspace_color2=None,
                 background_color_figure=&#39;white&#39;, background_color_plot=&#39;white&#39;, background_alpha=1,
                 style=None, light=None, dark=None,
                 # Spines
                 spine_color=None, spines_removed=(0, 0, 1, 1),
                 # Bounds
                 x_upper_bound=None, x_lower_bound=None,
                 y_upper_bound=None, y_lower_bound=None,
                 x_bounds=None, y_bounds=None,
                 # Pads
                 demo_pad_plot=False,
                 x_upper_resize_pad=0, x_lower_resize_pad=0,
                 y_upper_resize_pad=0, y_lower_resize_pad=0,
                 # Grid
                 grid=True, grid_color=&#39;lightgrey&#39;, grid_lines=&#39;-.&#39;,
                 # Title
                 title=None, title_size=12, title_y=1.025, title_weight=None, title_font=None, title_color=None,
                 # Labels
                 x_label=None, x_label_size=12, x_label_pad=10, x_label_rotation=None, x_label_weight=None,
                 y_label=None, y_label_size=12, y_label_pad=10, y_label_rotation=None, y_label_weight=None,
                 # Ticks
                 x_tick_number=5,
                 y_tick_number=5,
                 x_label_coords=None, y_label_coords=None,
                 tick_color=None, tick_label_pad=5,
                 ticks_where=(1, 1, 0, 0),
                 # Tick labels
                 tick_label_size=10, x_tick_label_size=None, y_tick_label_size=None,
                 x_custom_tick_locations=None, y_custom_tick_locations=None, fine_tick_locations=True,
                 x_custom_tick_labels=None, y_custom_tick_labels=None,
                 x_date_tick_labels=False, date_format=&#39;%Y-%m-%d&#39;,
                 tick_ndecimals=1, x_tick_ndecimals=None, y_tick_ndecimals=None,
                 x_tick_rotation=None, y_tick_rotation=None,
                 tick_labels_where=(1, 1, 0, 0),
                 # Color bar
                 color_bar=False, cb_pad=0.2, cb_axis_labelpad=10, shrink=0.75, extend=&#39;neither&#39;,
                 cb_title=None, cb_orientation=&#39;vertical&#39;,
                 cb_title_rotation=None, cb_title_style=&#39;normal&#39;, cb_title_size=10,
                 cb_top_title_y=1, cb_ytitle_labelpad=10, cb_title_weight=&#39;normal&#39;, cb_top_title=False,
                 cb_y_title=False, cb_top_title_pad=None, x_cb_top_title=0,
                 cb_vmin=None, cb_vmax=None, cb_hard_bounds=False, cb_outline_width=None,
                 cb_tick_number=5, cb_ticklabelsize=10, cb_tick_ndecimals=None,
                 # Legend
                 plot_label=None,
                 legend=False, legend_loc=&#39;upper right&#39;, legend_bbox_to_anchor=None,
                 legend_size=13, legend_weight=&#39;normal&#39;,
                 legend_style=&#39;normal&#39;, legend_handleheight=None, legend_ncol=1,
                 # Subplots
                 show=False, zorder=None,
                 # Save
                 filename=None, dpi=None,
                 # Suppress output
                 suppress=True
                 ):
        &#34;&#34;&#34;
        Quiver plot class
        mpl_plotter - 2D

        Specifics
        :param x: x
        :param y: y
        :param u: u
        :param v: v
        :param rule:  lambda function of u and v
            rule = lambda u, v: (u**2+v**2)
        :param custom_rule: Array assigning a color to each (x, y, u, v) vector
        :param vector_width: Vector width
        :param vector_min_shaft: Minimum vector shaft
        :param vector_length_threshold: Minimum vector length

        Color:
        :param color: Solid color
        :param cmap: Colormap
        :param alpha: Alpha
        :param norm: Norm to assign colormap values

        Other
        :param backend: Interactive plotting backends. Working with Python 3.7.6: Qt5Agg, QT4Agg, TkAgg.
                        Backend error:
                            pip install pyqt5
                            pip install tkinter
                            pip install tk
                            ... stackoverflow
                        Plotting window freezes even if trying different backends with no backend error: python configuration problem
                            backend=None
        &#34;&#34;&#34;
        # Turn all instance arguments to instance attributes
        for item in inspect.signature(quiver).parameters:
            setattr(self, item, eval(item))

        self.init()

    def plot(self):

        # Color rule
        self.method_rule()

        self.graph = self.ax.quiver(self.x, self.y, self.u, self.v,
                                    color=self.color, cmap=self.cmap,
                                    width=self.vector_width,
                                    minshaft=self.vector_min_shaft,
                                    minlength=self.vector_length_threshold,
                                    label=self.plot_label,
                                    zorder=self.zorder,
                                    alpha=self.alpha
                                    )

    def mock(self):
        if isinstance(self.x, type(None)) and isinstance(self.y, type(None)):
            self.x = np.random.random(100)
            self.y = np.random.random(100)
            self.u = np.random.random(100)
            self.v = np.random.random(100)
            self.norm = np.sqrt(self.u ** 2 + self.v ** 2)

    def method_rule(self):
        # Rule
        if isinstance(self.custom_rule, type(None)):
            if isinstance(self.rule, type(None)):
                self.rule = lambda u, v: (u ** 2 + v ** 2)
            self.rule = self.rule(u=self.u, v=self.v)
        else:
            self.rule = self.custom_rule

        # Color determined by rule function
        c = self.rule
        # Flatten and normalize
        c = (c.ravel() - c.min())/c.ptp()
        # Repeat for each body line and two head lines
        c = np.concatenate((c, np.repeat(c, 2)))
        # Colormap
        cmap = mpl.cm.get_cmap(self.cmap)
        self.color = cmap(c)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mpl_plotter.two_d.plot" href="#mpl_plotter.two_d.plot">plot</a></li>
<li><a title="mpl_plotter.two_d.canvas" href="#mpl_plotter.two_d.canvas">canvas</a></li>
<li><a title="mpl_plotter.two_d.attributes" href="#mpl_plotter.two_d.attributes">attributes</a></li>
<li><a title="mpl_plotter.two_d.std_input" href="#mpl_plotter.two_d.std_input">std_input</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpl_plotter.presets.custom.two_d.quiver" href="presets/custom.html#mpl_plotter.presets.custom.two_d.quiver">two_d.quiver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mpl_plotter.two_d.quiver.method_rule"><code class="name flex">
<span>def <span class="ident">method_rule</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_rule(self):
    # Rule
    if isinstance(self.custom_rule, type(None)):
        if isinstance(self.rule, type(None)):
            self.rule = lambda u, v: (u ** 2 + v ** 2)
        self.rule = self.rule(u=self.u, v=self.v)
    else:
        self.rule = self.custom_rule

    # Color determined by rule function
    c = self.rule
    # Flatten and normalize
    c = (c.ravel() - c.min())/c.ptp()
    # Repeat for each body line and two head lines
    c = np.concatenate((c, np.repeat(c, 2)))
    # Colormap
    cmap = mpl.cm.get_cmap(self.cmap)
    self.color = cmap(c)</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.quiver.mock"><code class="name flex">
<span>def <span class="ident">mock</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mock(self):
    if isinstance(self.x, type(None)) and isinstance(self.y, type(None)):
        self.x = np.random.random(100)
        self.y = np.random.random(100)
        self.u = np.random.random(100)
        self.v = np.random.random(100)
        self.norm = np.sqrt(self.u ** 2 + self.v ** 2)</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.quiver.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self):

    # Color rule
    self.method_rule()

    self.graph = self.ax.quiver(self.x, self.y, self.u, self.v,
                                color=self.color, cmap=self.cmap,
                                width=self.vector_width,
                                minshaft=self.vector_min_shaft,
                                minlength=self.vector_length_threshold,
                                label=self.plot_label,
                                zorder=self.zorder,
                                alpha=self.alpha
                                )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mpl_plotter.two_d.plot" href="#mpl_plotter.two_d.plot">plot</a></b></code>:
<ul class="hlist">
<li><code><a title="mpl_plotter.two_d.plot.method_fonts" href="#mpl_plotter.two_d.canvas.method_fonts">method_fonts</a></code></li>
<li><code><a title="mpl_plotter.two_d.plot.method_ticks" href="#mpl_plotter.two_d.attributes.method_ticks">method_ticks</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mpl_plotter.two_d.scatter"><code class="flex name class">
<span>class <span class="ident">scatter</span></span>
<span>(</span><span>x=None, y=None, point_size=5, marker='o', color='C0', cmap='RdBu_r', alpha=None, norm=None, backend='Qt5Agg', font='serif', math_font='dejavuserif', font_color='black', font_size_increase=0, fig=None, ax=None, figsize=None, shape_and_position=111, prune=None, resize_axes=True, scale=None, aspect=1, workspace_color=None, workspace_color2=None, background_color_figure='white', background_color_plot='white', background_alpha=1, style=None, light=None, dark=None, spine_color=None, spines_removed=(0, 0, 1, 1), x_upper_bound=None, x_lower_bound=None, y_upper_bound=None, y_lower_bound=None, x_bounds=None, y_bounds=None, demo_pad_plot=False, x_upper_resize_pad=0, x_lower_resize_pad=0, y_upper_resize_pad=0, y_lower_resize_pad=0, grid=True, grid_color='lightgrey', grid_lines='-.', title=None, title_size=12, title_y=1.025, title_weight=None, title_font=None, title_color=None, x_label=None, x_label_size=12, x_label_pad=10, x_label_rotation=None, x_label_weight=None, y_label=None, y_label_size=12, y_label_pad=10, y_label_rotation=None, y_label_weight=None, x_tick_number=5, y_tick_number=5, x_label_coords=None, y_label_coords=None, tick_color=None, tick_label_pad=5, ticks_where=(1, 1, 0, 0), tick_label_size=10, x_tick_label_size=None, y_tick_label_size=None, x_custom_tick_locations=None, y_custom_tick_locations=None, fine_tick_locations=True, x_custom_tick_labels=None, y_custom_tick_labels=None, x_date_tick_labels=False, date_format='%Y-%m-%d', tick_ndecimals=1, x_tick_ndecimals=None, y_tick_ndecimals=None, x_tick_rotation=None, y_tick_rotation=None, tick_labels_where=(1, 1, 0, 0), color_bar=False, cb_pad=0.2, cb_axis_labelpad=10, shrink=0.75, extend='neither', cb_title=None, cb_orientation='vertical', cb_title_rotation=None, cb_title_style='normal', cb_title_size=10, cb_top_title_y=1, cb_ytitle_labelpad=10, cb_title_weight='normal', cb_top_title=False, cb_y_title=False, cb_top_title_pad=None, x_cb_top_title=0, cb_vmin=None, cb_vmax=None, cb_hard_bounds=False, cb_outline_width=None, cb_tick_number=5, cb_ticklabelsize=10, cb_tick_ndecimals=None, plot_label=None, legend=False, legend_loc='upper right', legend_bbox_to_anchor=None, legend_size=13, legend_weight='normal', legend_style='normal', legend_handleheight=None, legend_ncol=1, show=False, zorder=None, filename=None, dpi=None, suppress=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Scatter plot class
mpl_plotter - 2D</p>
<p>Specifics
:param x: x
:param y: y
:param point_size: Point size
:param marker: Dot marker</p>
<p>Color:
:param color: Solid color
:param cmap: Colormap
:param alpha: Alpha
:param norm: Norm to assign colormap values</p>
<p>Other
:param backend: Interactive plotting backends. Working with Python 3.7.6: Qt5Agg, QT4Agg, TkAgg.
Backend error:
pip install pyqt5
pip install tkinter
pip install tk
&hellip; stackoverflow
Plotting window freezes even if trying different backends with no backend error: python configuration problem
backend=None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class scatter(plot, std_input):

    def __init__(self,
                 # Specifics
                 x=None, y=None, point_size=5, marker=&#39;o&#39;,
                 # Specifics: color
                 color=&#34;C0&#34;, cmap=&#39;RdBu_r&#39;, alpha=None, norm=None,
                 # Backend
                 backend=&#39;Qt5Agg&#39;,
                 # Fonts
                 font=&#39;serif&#39;, math_font=&#34;dejavuserif&#34;, font_color=&#34;black&#34;, font_size_increase=0,
                 # Figure, axes
                 fig=None, ax=None, figsize=None, shape_and_position=111, prune=None, resize_axes=True,
                 scale=None, aspect=1,
                 # Setup
                 workspace_color=None, workspace_color2=None,
                 background_color_figure=&#39;white&#39;, background_color_plot=&#39;white&#39;, background_alpha=1,
                 style=None, light=None, dark=None,
                 # Spines
                 spine_color=None, spines_removed=(0, 0, 1, 1),
                 # Bounds
                 x_upper_bound=None, x_lower_bound=None,
                 y_upper_bound=None, y_lower_bound=None,
                 x_bounds=None, y_bounds=None,
                 # Pads
                 demo_pad_plot=False,
                 x_upper_resize_pad=0, x_lower_resize_pad=0,
                 y_upper_resize_pad=0, y_lower_resize_pad=0,
                 # Grid
                 grid=True, grid_color=&#39;lightgrey&#39;, grid_lines=&#39;-.&#39;,
                 # Title
                 title=None, title_size=12, title_y=1.025, title_weight=None, title_font=None, title_color=None,
                 # Labels
                 x_label=None, x_label_size=12, x_label_pad=10, x_label_rotation=None, x_label_weight=None,
                 y_label=None, y_label_size=12, y_label_pad=10, y_label_rotation=None, y_label_weight=None,
                 # Ticks
                 x_tick_number=5,
                 y_tick_number=5,
                 x_label_coords=None, y_label_coords=None,
                 tick_color=None, tick_label_pad=5,
                 ticks_where=(1, 1, 0, 0),
                 # Tick labels
                 tick_label_size=10, x_tick_label_size=None, y_tick_label_size=None,
                 x_custom_tick_locations=None, y_custom_tick_locations=None, fine_tick_locations=True,
                 x_custom_tick_labels=None, y_custom_tick_labels=None,
                 x_date_tick_labels=False, date_format=&#39;%Y-%m-%d&#39;,
                 tick_ndecimals=1, x_tick_ndecimals=None, y_tick_ndecimals=None,
                 x_tick_rotation=None, y_tick_rotation=None,
                 tick_labels_where=(1, 1, 0, 0),
                 # Color bar
                 color_bar=False, cb_pad=0.2, cb_axis_labelpad=10, shrink=0.75, extend=&#39;neither&#39;,
                 cb_title=None, cb_orientation=&#39;vertical&#39;,
                 cb_title_rotation=None, cb_title_style=&#39;normal&#39;, cb_title_size=10,
                 cb_top_title_y=1, cb_ytitle_labelpad=10, cb_title_weight=&#39;normal&#39;, cb_top_title=False,
                 cb_y_title=False, cb_top_title_pad=None, x_cb_top_title=0,
                 cb_vmin=None, cb_vmax=None, cb_hard_bounds=False, cb_outline_width=None,
                 cb_tick_number=5, cb_ticklabelsize=10, cb_tick_ndecimals=None,
                 # Legend
                 plot_label=None,
                 legend=False, legend_loc=&#39;upper right&#39;, legend_bbox_to_anchor=None,
                 legend_size=13, legend_weight=&#39;normal&#39;,
                 legend_style=&#39;normal&#39;, legend_handleheight=None, legend_ncol=1,
                 # Subplots
                 show=False, zorder=None,
                 # Save
                 filename=None, dpi=None,
                 # Suppress output
                 suppress=True
                 ):
        &#34;&#34;&#34;
        Scatter plot class
        mpl_plotter - 2D

        Specifics
        :param x: x
        :param y: y
        :param point_size: Point size
        :param marker: Dot marker

        Color:
        :param color: Solid color
        :param cmap: Colormap
        :param alpha: Alpha
        :param norm: Norm to assign colormap values

        Other
        :param backend: Interactive plotting backends. Working with Python 3.7.6: Qt5Agg, QT4Agg, TkAgg.
                        Backend error:
                            pip install pyqt5
                            pip install tkinter
                            pip install tk
                            ... stackoverflow
                        Plotting window freezes even if trying different backends with no backend error: python configuration problem
                            backend=None
        &#34;&#34;&#34;

        # Turn all instance arguments to instance attributes
        for item in inspect.signature(scatter).parameters:
            setattr(self, item, eval(item))

        self.init()

    def plot(self):

        if not isinstance(self.norm, type(None)):
            self.graph = self.ax.scatter(self.x, self.y, label=self.plot_label, s=self.point_size, marker=self.marker,
                                         c=self.norm, cmap=self.cmap,
                                         zorder=self.zorder,
                                         alpha=self.alpha)
        else:
            self.graph = self.ax.scatter(self.x, self.y, label=self.plot_label, s=self.point_size, marker=self.marker,
                                         color=self.color,
                                         zorder=self.zorder,
                                         alpha=self.alpha)

    def mock(self):
        if isinstance(self.x, type(None)) and isinstance(self.y, type(None)):
            self.x, self.y = MockData().spirograph()
            self.norm = self.y</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mpl_plotter.two_d.plot" href="#mpl_plotter.two_d.plot">plot</a></li>
<li><a title="mpl_plotter.two_d.canvas" href="#mpl_plotter.two_d.canvas">canvas</a></li>
<li><a title="mpl_plotter.two_d.attributes" href="#mpl_plotter.two_d.attributes">attributes</a></li>
<li><a title="mpl_plotter.two_d.std_input" href="#mpl_plotter.two_d.std_input">std_input</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpl_plotter.presets.custom.two_d.scatter" href="presets/custom.html#mpl_plotter.presets.custom.two_d.scatter">two_d.scatter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mpl_plotter.two_d.scatter.mock"><code class="name flex">
<span>def <span class="ident">mock</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mock(self):
    if isinstance(self.x, type(None)) and isinstance(self.y, type(None)):
        self.x, self.y = MockData().spirograph()
        self.norm = self.y</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.scatter.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self):

    if not isinstance(self.norm, type(None)):
        self.graph = self.ax.scatter(self.x, self.y, label=self.plot_label, s=self.point_size, marker=self.marker,
                                     c=self.norm, cmap=self.cmap,
                                     zorder=self.zorder,
                                     alpha=self.alpha)
    else:
        self.graph = self.ax.scatter(self.x, self.y, label=self.plot_label, s=self.point_size, marker=self.marker,
                                     color=self.color,
                                     zorder=self.zorder,
                                     alpha=self.alpha)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mpl_plotter.two_d.plot" href="#mpl_plotter.two_d.plot">plot</a></b></code>:
<ul class="hlist">
<li><code><a title="mpl_plotter.two_d.plot.method_fonts" href="#mpl_plotter.two_d.canvas.method_fonts">method_fonts</a></code></li>
<li><code><a title="mpl_plotter.two_d.plot.method_ticks" href="#mpl_plotter.two_d.attributes.method_ticks">method_ticks</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="mpl_plotter.two_d.std_input"><code class="flex name class">
<span>class <span class="ident">std_input</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class std_input():

    def custom(self):
        # Resize axes
        self.method_resize_axes()
        # Legend
        self.method_legend()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpl_plotter.two_d.fill_area" href="#mpl_plotter.two_d.fill_area">fill_area</a></li>
<li><a title="mpl_plotter.two_d.line" href="#mpl_plotter.two_d.line">line</a></li>
<li><a title="mpl_plotter.two_d.quiver" href="#mpl_plotter.two_d.quiver">quiver</a></li>
<li><a title="mpl_plotter.two_d.scatter" href="#mpl_plotter.two_d.scatter">scatter</a></li>
<li><a title="mpl_plotter.two_d.streamline" href="#mpl_plotter.two_d.streamline">streamline</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mpl_plotter.two_d.std_input.custom"><code class="name flex">
<span>def <span class="ident">custom</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom(self):
    # Resize axes
    self.method_resize_axes()
    # Legend
    self.method_legend()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="mpl_plotter.two_d.streamline"><code class="flex name class">
<span>class <span class="ident">streamline</span></span>
<span>(</span><span>x=None, y=None, u=None, v=None, line_width=1, line_density=2, color=None, cmap='RdBu_r', alpha=None, norm=None, backend='Qt5Agg', font='serif', math_font='dejavuserif', font_color='black', font_size_increase=0, fig=None, ax=None, figsize=None, shape_and_position=111, prune=None, resize_axes=True, scale=None, aspect=1, workspace_color=None, workspace_color2=None, background_color_figure='white', background_color_plot='white', background_alpha=1, style=None, light=None, dark=None, spine_color=None, spines_removed=(0, 0, 1, 1), x_upper_bound=None, x_lower_bound=None, y_upper_bound=None, y_lower_bound=None, x_bounds=None, y_bounds=None, demo_pad_plot=False, x_upper_resize_pad=0, x_lower_resize_pad=0, y_upper_resize_pad=0, y_lower_resize_pad=0, grid=True, grid_color='lightgrey', grid_lines='-.', title=None, title_size=12, title_y=1.025, title_weight=None, title_font=None, title_color=None, x_label=None, x_label_size=12, x_label_pad=10, x_label_rotation=None, x_label_weight=None, y_label=None, y_label_size=12, y_label_pad=10, y_label_rotation=None, y_label_weight=None, x_tick_number=5, y_tick_number=5, x_label_coords=None, y_label_coords=None, tick_color=None, tick_label_pad=5, ticks_where=(1, 1, 0, 0), tick_label_size=10, x_tick_label_size=None, y_tick_label_size=None, x_custom_tick_locations=None, y_custom_tick_locations=None, fine_tick_locations=True, x_custom_tick_labels=None, y_custom_tick_labels=None, x_date_tick_labels=False, date_format='%Y-%m-%d', tick_ndecimals=1, x_tick_ndecimals=None, y_tick_ndecimals=None, x_tick_rotation=None, y_tick_rotation=None, tick_labels_where=(1, 1, 0, 0), color_bar=False, cb_pad=0.2, cb_axis_labelpad=10, shrink=0.75, extend='neither', cb_title=None, cb_orientation='vertical', cb_title_rotation=None, cb_title_style='normal', cb_title_size=10, cb_top_title_y=1, cb_ytitle_labelpad=10, cb_title_weight='normal', cb_top_title=False, cb_y_title=False, cb_top_title_pad=None, x_cb_top_title=0, cb_vmin=None, cb_vmax=None, cb_hard_bounds=False, cb_outline_width=None, cb_tick_number=5, cb_ticklabelsize=10, cb_tick_ndecimals=None, plot_label=None, legend=False, legend_loc='upper right', legend_bbox_to_anchor=None, legend_size=13, legend_weight='normal', legend_style='normal', legend_handleheight=None, legend_ncol=1, show=False, zorder=None, filename=None, dpi=None, suppress=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Streamline class
mpl_plotter - 2D</p>
<p>Specifics
:param x: x
:param y: y
:param u: u
:param v: v
:param line_width: Streamline width
:param line_density: Measure of the amount of streamlines displayed. Low value (default=2)</p>
<p>Color:
:param color: Solid color
:param cmap: Colormap
:param alpha: Alpha
:param norm: Norm to assign colormap values</p>
<p>Other
:param backend: Interactive plotting backends. Working with Python 3.7.6: Qt5Agg, QT4Agg, TkAgg.
Backend error:
pip install pyqt5
pip install tkinter
pip install tk
&hellip; stackoverflow
Plotting window freezes even if trying different backends with no backend error: python configuration problem
backend=None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class streamline(plot, std_input):

    def __init__(self,
                 # Specifics
                 x=None, y=None, u=None, v=None, line_width=1, line_density=2,
                 # Specifics: color
                 color=None, cmap=&#39;RdBu_r&#39;, alpha=None, norm=None,
                 # Backend
                 backend=&#39;Qt5Agg&#39;,
                 # Fonts
                 font=&#39;serif&#39;, math_font=&#34;dejavuserif&#34;, font_color=&#34;black&#34;, font_size_increase=0,
                 # Figure, axes
                 fig=None, ax=None, figsize=None, shape_and_position=111, prune=None, resize_axes=True,
                 scale=None, aspect=1,
                 # Setup
                 workspace_color=None, workspace_color2=None,
                 background_color_figure=&#39;white&#39;, background_color_plot=&#39;white&#39;, background_alpha=1,
                 style=None, light=None, dark=None,
                 # Spines
                 spine_color=None, spines_removed=(0, 0, 1, 1),
                 # Bounds
                 x_upper_bound=None, x_lower_bound=None,
                 y_upper_bound=None, y_lower_bound=None,
                 x_bounds=None, y_bounds=None,
                 # Pads
                 demo_pad_plot=False,
                 x_upper_resize_pad=0, x_lower_resize_pad=0,
                 y_upper_resize_pad=0, y_lower_resize_pad=0,
                 # Grid
                 grid=True, grid_color=&#39;lightgrey&#39;, grid_lines=&#39;-.&#39;,
                 # Title
                 title=None, title_size=12, title_y=1.025, title_weight=None, title_font=None, title_color=None,
                 # Labels
                 x_label=None, x_label_size=12, x_label_pad=10, x_label_rotation=None, x_label_weight=None,
                 y_label=None, y_label_size=12, y_label_pad=10, y_label_rotation=None, y_label_weight=None,
                 # Ticks
                 x_tick_number=5,
                 y_tick_number=5,
                 x_label_coords=None, y_label_coords=None,
                 tick_color=None, tick_label_pad=5,
                 ticks_where=(1, 1, 0, 0),
                 # Tick labels
                 tick_label_size=10, x_tick_label_size=None, y_tick_label_size=None,
                 x_custom_tick_locations=None, y_custom_tick_locations=None, fine_tick_locations=True,
                 x_custom_tick_labels=None, y_custom_tick_labels=None,
                 x_date_tick_labels=False, date_format=&#39;%Y-%m-%d&#39;,
                 tick_ndecimals=1, x_tick_ndecimals=None, y_tick_ndecimals=None,
                 x_tick_rotation=None, y_tick_rotation=None,
                 tick_labels_where=(1, 1, 0, 0),
                 # Color bar
                 color_bar=False, cb_pad=0.2, cb_axis_labelpad=10, shrink=0.75, extend=&#39;neither&#39;,
                 cb_title=None, cb_orientation=&#39;vertical&#39;,
                 cb_title_rotation=None, cb_title_style=&#39;normal&#39;, cb_title_size=10,
                 cb_top_title_y=1, cb_ytitle_labelpad=10, cb_title_weight=&#39;normal&#39;, cb_top_title=False,
                 cb_y_title=False, cb_top_title_pad=None, x_cb_top_title=0,
                 cb_vmin=None, cb_vmax=None, cb_hard_bounds=False, cb_outline_width=None,
                 cb_tick_number=5, cb_ticklabelsize=10, cb_tick_ndecimals=None,
                 # Legend
                 plot_label=None,
                 legend=False, legend_loc=&#39;upper right&#39;, legend_bbox_to_anchor=None,
                 legend_size=13, legend_weight=&#39;normal&#39;,
                 legend_style=&#39;normal&#39;, legend_handleheight=None, legend_ncol=1,
                 # Subplots
                 show=False, zorder=None,
                 # Save
                 filename=None, dpi=None,
                 # Suppress output
                 suppress=True
                 ):
        &#34;&#34;&#34;
        Streamline class
        mpl_plotter - 2D

        Specifics
        :param x: x
        :param y: y
        :param u: u
        :param v: v
        :param line_width: Streamline width
        :param line_density: Measure of the amount of streamlines displayed. Low value (default=2)


        Color:
        :param color: Solid color
        :param cmap: Colormap
        :param alpha: Alpha
        :param norm: Norm to assign colormap values

        Other
        :param backend: Interactive plotting backends. Working with Python 3.7.6: Qt5Agg, QT4Agg, TkAgg.
                        Backend error:
                            pip install pyqt5
                            pip install tkinter
                            pip install tk
                            ... stackoverflow
                        Plotting window freezes even if trying different backends with no backend error: python configuration problem
                            backend=None
        &#34;&#34;&#34;

        # Turn all instance arguments to instance attributes
        for item in inspect.signature(streamline).parameters:
            setattr(self, item, eval(item))

        self.init()

    def plot(self):

        # Color rule
        self.method_rule()

        # Plot
        self.graph = self.ax.streamplot(self.x, self.y, self.u, self.v,
                                        color=self.color,
                                        cmap=self.cmap,
                                        linewidth=self.line_width,
                                        density=self.line_density,
                                        zorder=self.zorder,
                                        ).lines

    def mock(self):
        if isinstance(self.x, type(None)) and isinstance(self.y, type(None)):
            self.x = np.linspace(0, 10, 100)
            self.y = np.linspace(0, 10, 100)
            self.x, self.y = np.meshgrid(self.x, self.y)
            self.u = np.cos(self.x)
            self.v = np.cos(self.y)
            self.color = self.u

    def method_rule(self):
        if isinstance(self.color, type(None)):
            rule_color = lambda u: np.sqrt(self.u ** 2 + self.v ** 2) / np.sqrt(self.u.max() ** 2 + self.v.max() ** 2)
            self.color = rule_color(self.u)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="mpl_plotter.two_d.plot" href="#mpl_plotter.two_d.plot">plot</a></li>
<li><a title="mpl_plotter.two_d.canvas" href="#mpl_plotter.two_d.canvas">canvas</a></li>
<li><a title="mpl_plotter.two_d.attributes" href="#mpl_plotter.two_d.attributes">attributes</a></li>
<li><a title="mpl_plotter.two_d.std_input" href="#mpl_plotter.two_d.std_input">std_input</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="mpl_plotter.presets.custom.two_d.streamline" href="presets/custom.html#mpl_plotter.presets.custom.two_d.streamline">two_d.streamline</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="mpl_plotter.two_d.streamline.method_rule"><code class="name flex">
<span>def <span class="ident">method_rule</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_rule(self):
    if isinstance(self.color, type(None)):
        rule_color = lambda u: np.sqrt(self.u ** 2 + self.v ** 2) / np.sqrt(self.u.max() ** 2 + self.v.max() ** 2)
        self.color = rule_color(self.u)</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.streamline.mock"><code class="name flex">
<span>def <span class="ident">mock</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mock(self):
    if isinstance(self.x, type(None)) and isinstance(self.y, type(None)):
        self.x = np.linspace(0, 10, 100)
        self.y = np.linspace(0, 10, 100)
        self.x, self.y = np.meshgrid(self.x, self.y)
        self.u = np.cos(self.x)
        self.v = np.cos(self.y)
        self.color = self.u</code></pre>
</details>
</dd>
<dt id="mpl_plotter.two_d.streamline.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self):

    # Color rule
    self.method_rule()

    # Plot
    self.graph = self.ax.streamplot(self.x, self.y, self.u, self.v,
                                    color=self.color,
                                    cmap=self.cmap,
                                    linewidth=self.line_width,
                                    density=self.line_density,
                                    zorder=self.zorder,
                                    ).lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="mpl_plotter.two_d.plot" href="#mpl_plotter.two_d.plot">plot</a></b></code>:
<ul class="hlist">
<li><code><a title="mpl_plotter.two_d.plot.method_fonts" href="#mpl_plotter.two_d.canvas.method_fonts">method_fonts</a></code></li>
<li><code><a title="mpl_plotter.two_d.plot.method_ticks" href="#mpl_plotter.two_d.attributes.method_ticks">method_ticks</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mpl_plotter" href="index.html">mpl_plotter</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mpl_plotter.two_d.floating_text" href="#mpl_plotter.two_d.floating_text">floating_text</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mpl_plotter.two_d.attributes" href="#mpl_plotter.two_d.attributes">attributes</a></code></h4>
<ul class="">
<li><code><a title="mpl_plotter.two_d.attributes.method_axis_labels" href="#mpl_plotter.two_d.attributes.method_axis_labels">method_axis_labels</a></code></li>
<li><code><a title="mpl_plotter.two_d.attributes.method_background_color" href="#mpl_plotter.two_d.attributes.method_background_color">method_background_color</a></code></li>
<li><code><a title="mpl_plotter.two_d.attributes.method_cb" href="#mpl_plotter.two_d.attributes.method_cb">method_cb</a></code></li>
<li><code><a title="mpl_plotter.two_d.attributes.method_legend" href="#mpl_plotter.two_d.attributes.method_legend">method_legend</a></code></li>
<li><code><a title="mpl_plotter.two_d.attributes.method_resize_axes" href="#mpl_plotter.two_d.attributes.method_resize_axes">method_resize_axes</a></code></li>
<li><code><a title="mpl_plotter.two_d.attributes.method_spines" href="#mpl_plotter.two_d.attributes.method_spines">method_spines</a></code></li>
<li><code><a title="mpl_plotter.two_d.attributes.method_ticks" href="#mpl_plotter.two_d.attributes.method_ticks">method_ticks</a></code></li>
<li><code><a title="mpl_plotter.two_d.attributes.method_title" href="#mpl_plotter.two_d.attributes.method_title">method_title</a></code></li>
<li><code><a title="mpl_plotter.two_d.attributes.method_workspace_style" href="#mpl_plotter.two_d.attributes.method_workspace_style">method_workspace_style</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mpl_plotter.two_d.canvas" href="#mpl_plotter.two_d.canvas">canvas</a></code></h4>
<ul class="">
<li><code><a title="mpl_plotter.two_d.canvas.method_backend" href="#mpl_plotter.two_d.canvas.method_backend">method_backend</a></code></li>
<li><code><a title="mpl_plotter.two_d.canvas.method_figure" href="#mpl_plotter.two_d.canvas.method_figure">method_figure</a></code></li>
<li><code><a title="mpl_plotter.two_d.canvas.method_fonts" href="#mpl_plotter.two_d.canvas.method_fonts">method_fonts</a></code></li>
<li><code><a title="mpl_plotter.two_d.canvas.method_grid" href="#mpl_plotter.two_d.canvas.method_grid">method_grid</a></code></li>
<li><code><a title="mpl_plotter.two_d.canvas.method_setup" href="#mpl_plotter.two_d.canvas.method_setup">method_setup</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mpl_plotter.two_d.df_input" href="#mpl_plotter.two_d.df_input">df_input</a></code></h4>
<ul class="">
<li><code><a title="mpl_plotter.two_d.df_input.method_resize_axes_dataframe" href="#mpl_plotter.two_d.df_input.method_resize_axes_dataframe">method_resize_axes_dataframe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mpl_plotter.two_d.fill_area" href="#mpl_plotter.two_d.fill_area">fill_area</a></code></h4>
<ul class="">
<li><code><a title="mpl_plotter.two_d.fill_area.i_above" href="#mpl_plotter.two_d.fill_area.i_above">i_above</a></code></li>
<li><code><a title="mpl_plotter.two_d.fill_area.i_below" href="#mpl_plotter.two_d.fill_area.i_below">i_below</a></code></li>
<li><code><a title="mpl_plotter.two_d.fill_area.intersection" href="#mpl_plotter.two_d.fill_area.intersection">intersection</a></code></li>
<li><code><a title="mpl_plotter.two_d.fill_area.mock" href="#mpl_plotter.two_d.fill_area.mock">mock</a></code></li>
<li><code><a title="mpl_plotter.two_d.fill_area.plot" href="#mpl_plotter.two_d.fill_area.plot">plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mpl_plotter.two_d.heatmap" href="#mpl_plotter.two_d.heatmap">heatmap</a></code></h4>
<ul class="">
<li><code><a title="mpl_plotter.two_d.heatmap.mock" href="#mpl_plotter.two_d.heatmap.mock">mock</a></code></li>
<li><code><a title="mpl_plotter.two_d.heatmap.plot" href="#mpl_plotter.two_d.heatmap.plot">plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mpl_plotter.two_d.line" href="#mpl_plotter.two_d.line">line</a></code></h4>
<ul class="">
<li><code><a title="mpl_plotter.two_d.line.mock" href="#mpl_plotter.two_d.line.mock">mock</a></code></li>
<li><code><a title="mpl_plotter.two_d.line.plot" href="#mpl_plotter.two_d.line.plot">plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mpl_plotter.two_d.plot" href="#mpl_plotter.two_d.plot">plot</a></code></h4>
<ul class="two-column">
<li><code><a title="mpl_plotter.two_d.plot.finish" href="#mpl_plotter.two_d.plot.finish">finish</a></code></li>
<li><code><a title="mpl_plotter.two_d.plot.init" href="#mpl_plotter.two_d.plot.init">init</a></code></li>
<li><code><a title="mpl_plotter.two_d.plot.main" href="#mpl_plotter.two_d.plot.main">main</a></code></li>
<li><code><a title="mpl_plotter.two_d.plot.method_save" href="#mpl_plotter.two_d.plot.method_save">method_save</a></code></li>
<li><code><a title="mpl_plotter.two_d.plot.method_show" href="#mpl_plotter.two_d.plot.method_show">method_show</a></code></li>
<li><code><a title="mpl_plotter.two_d.plot.run" href="#mpl_plotter.two_d.plot.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mpl_plotter.two_d.quiver" href="#mpl_plotter.two_d.quiver">quiver</a></code></h4>
<ul class="">
<li><code><a title="mpl_plotter.two_d.quiver.method_rule" href="#mpl_plotter.two_d.quiver.method_rule">method_rule</a></code></li>
<li><code><a title="mpl_plotter.two_d.quiver.mock" href="#mpl_plotter.two_d.quiver.mock">mock</a></code></li>
<li><code><a title="mpl_plotter.two_d.quiver.plot" href="#mpl_plotter.two_d.quiver.plot">plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mpl_plotter.two_d.scatter" href="#mpl_plotter.two_d.scatter">scatter</a></code></h4>
<ul class="">
<li><code><a title="mpl_plotter.two_d.scatter.mock" href="#mpl_plotter.two_d.scatter.mock">mock</a></code></li>
<li><code><a title="mpl_plotter.two_d.scatter.plot" href="#mpl_plotter.two_d.scatter.plot">plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mpl_plotter.two_d.std_input" href="#mpl_plotter.two_d.std_input">std_input</a></code></h4>
<ul class="">
<li><code><a title="mpl_plotter.two_d.std_input.custom" href="#mpl_plotter.two_d.std_input.custom">custom</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="mpl_plotter.two_d.streamline" href="#mpl_plotter.two_d.streamline">streamline</a></code></h4>
<ul class="">
<li><code><a title="mpl_plotter.two_d.streamline.method_rule" href="#mpl_plotter.two_d.streamline.method_rule">method_rule</a></code></li>
<li><code><a title="mpl_plotter.two_d.streamline.mock" href="#mpl_plotter.two_d.streamline.mock">mock</a></code></li>
<li><code><a title="mpl_plotter.two_d.streamline.plot" href="#mpl_plotter.two_d.streamline.plot">plot</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>